[{"id":"709b09d4ae43a807a27c1aa5f06ca26b","title":"Compoer","content":"\n\n\n\n\n\n\n\n\n💡 Tips：先了解一下历史，从拷贝第三方代码到项目中(1994)，到 PEAR 安装依赖包(1999)，再到 Composer 兴起(2012)，PHP 社区经历了将近 20 年的探索。PHP 这门古老的语言，也在不断的发展更新，在 Web 领域一直发光发热。 Composer 作为目前 PHP 包依赖管理的最佳工具，值得每一位 PHP 开发人员掌握。\n什么是 Composer？是 PHP 用来管理依赖（dependency）关系的工具。可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会自动安装这些依赖的库文件。\nCompoer 用法项目中的 composer.json 文件是 Composer 的核心配置文件，它规定了项目所需的依赖包以及它们的版本信息，从而指导 Composer 安装和管理这些依赖项。该文件中最重要的部分是 require 部分，该部分告诉 Composer 期望安装的包及其版本：\n\n\n安装依赖1composer install\n\n\n\n\n\n\n\nTIP\n在项目根目录下执行，composer install 命令，Composer 会自动分析依赖，安装最合适的包到 vendor 目录下，安装完毕后，vendor 目录下会生成 autoload.php 文件。在项目的入口文件中包含此文件：require DIR . “&#x2F;vendor&#x2F;autoload.php”;，接下来便可在项目的任何地方引用依赖包中的接口和类。\n\n常用命令\n\n\n命令\n描述\n\n\n\ncomposer search\n根据关键字查找依赖包\n\n\ncomposer request\n引入依赖，声明项目或者全局( global，用户名全局，非系统全局)依赖某个包\n\n\ncomposer install\n安装 composer.json 声明的依赖包，最终安装的依赖包版本可能取决于有无 composer.lock 文件\n\n\ncomposer update\n更新依赖到最新版本，相当于删除 composer.lock 文件后执行 composer install\n\n\ncomposer info\n查看安装的依赖包信息，与 composer show 等价\n\n\ncomposer dumpautoload\n加 -o 选项可导出优化的加载器\n\n\ncomposer why(-not)\n查看（不）安装某个包的原因\n\n\nComposer 加速Compoer 安装依赖比较慢，问题是资源都是在外国服务器上，Compoer 2.x 除了网络问题，它已经很快了，不需要在使用其它插件辅助了。切换国内源，所有的项目都会使用该镜像地址：\n1composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n\nComposer 加载机制Composer 是 PHP 中最受欢迎的依赖管理工具之一，它通过自动加载机制有效地管理项目的依赖关系。了解 Composer 的加载机制对于理解 PHP 项目的自动加载过程至关重要。\n1. composer.json 文件\n依赖声明： composer.json 文件是 Composer 的核心配置文件，其中声明了项目所需的依赖包及其版本要求；\n自动加载配置： composer.json 中的 autoload 字段定义了自动加载规则，告诉 Composer 如何加载项目中的类文件；\n\n2. 自动加载规则Composer 的自动加载规则基于 PSR-4 和 PSR-0 标准：\n\nPSR-4 规范： PSR-4 规定了类命名空间与目录结构之间的映射关系；\nPSR-0 规范： PSR-0 是早期的自动加载规范，已被 PSR-4 取代，但一些旧版的库仍然使用；\n\n3. Composer Autoload 指令Composer Autoload 指令是项目中的 autoload.php 文件，由 Composer 自动生成并负责自动加载类文件：\n\n引入 Autoload 文件： 项目的入口文件通常会引入 Composer 自动生成的 autoload.php 文件；\nAutoload 机制： autoload.php 文件通过注册自动加载函数（spl_autoload_register）来实现类的自动加载；\n\n4. 类的加载流程\n自动加载注册： 项目启动时，autoload.php 文件会注册自动加载函数，用于加载项目中的类文件；\n命名空间解析： 当代码中使用了未加载的类时，PHP 解释器会触发自动加载函数；\n自动加载函数： 自动加载函数根据类的命名空间和自动加载规则，找到对应的类文件并加载；\n\n5. 缓存机制Composer 提供了类加载的缓存机制，可以加速加载过程：\n\nClassmap： Composer 可以生成一个类映射表，加速类文件的查找过程；\nOptimize-autoloader： Composer 提供了 optimize-autoloader 指令（composer dumpautoload -o），用于生成和更新类加载的缓存文件；\n\n实现自动加载123456789101112131415161718&lt;?php// 定义项目根目录常量define(&#x27;ROOT_PATH&#x27;, __DIR__);// 自动加载函数spl_autoload_register(function ($className) &#123;    // 将类名转换为文件路径    $classFile = ROOT_PATH . &#x27;/&#x27; . str_replace(&#x27;\\\\&#x27;, &#x27;/&#x27;, $className) . &#x27;.php&#x27;;        // 检查类文件是否存在    if (file_exists($classFile)) &#123;        // 加载类文件        require_once $classFile;    &#125;&#125;);// 可选的其他初始化逻辑...\n\n\n\n\n\n\n\nTIP\nspl_autoload_register 函数用于注册自定义的自动加载函数，当 PHP 遇到未定义的类时，会触发这些自动加载函数来尝试加载对应的类文件。具体来说，spl_autoload_register 函数的调用会触发两种情况下的自动加载：\n\n使用未定义的类： 当代码中使用了一个未定义的类时，PHP 解释器会检测当前是否已经注册了自动加载函数。如果已经注册，则会按照注册的顺序依次调用这些自动加载函数，尝试加载这个未定义的类；\n手动调用 spl_autoload 函数： 如果需要手动触发自动加载，可以调用 spl_autoload 函数，并传入未定义的类名作为参数。这样 PHP 会立即尝试调用已注册的自动加载函数来加载这个类；\n\n\n\n","slug":"Compoer","date":"2024-02-22T10:58:00.000Z","categories_index":"","tags_index":"PHP","author_index":"哪吒"},{"id":"a48e6dda0c21e40880cba7e763278b04","title":"Docker","content":"\n\n\n\n\n\n\n\n\n💡 Tips：Docker 是一个开源的容器化平台，用于轻松打包、发布和运行应用程序。通过 Docker，开发者可以将应用程序及其依赖项打包到一个称为镜像的标准化单元中，然后在任何支持 Docker 的环境中部署这些镜像为容器。Docker 的核心原理是利用操作系统级虚拟化技术，如 Linux 容器 (LXC)，来创建轻量级、隔离的执行环境。这使得开发人员能够实现快速、一致和可靠的应用程序交付，并实现更高效的资源利用。\n三大核心\n镜像（Image）：镜像是一个轻量级、独立、可执行的软件包，它包含了运行应用程序所需的所有内容，包括代码、运行时、库、环境变量和配置文件等。Docker 镜像是通过文件系统的层叠方式构建而成的，每一层都是只读的，它们共同组成了最终的镜像；\n容器（Container）：容器是 Docker 镜像的运行实例。容器利用镜像提供的文件系统、代码和运行时环境，独立运行在宿主机上。每个容器都是相互隔离的，拥有自己的文件系统、网络和进程空间，但它们共享主机操作系统的内核；\n仓库（Repository）：仓库是用来存放 Docker 镜像的地方。它可以被看作是一个集中的存储库，用于管理和分享镜像。仓库分为两种类型：公有仓库和私有仓库。Docker Hub 是最常见的公有仓库，而私有仓库则可以搭建在本地或者在云服务上，用于组织内部或个人使用；\n\n常用命令\n\n\n命令\n解释\n\n\n\nsystemctl start docker\n启动 docker\n\n\nsystemctl restart docker\n重启 docker\n\n\ndocker images\n查看所有镜像\n\n\ndocker pull 镜像\n在 dockerhub 当中拉取镜像\n\n\ndocker rmi 镜像\n删除镜像\n\n\ndocker ps\n查看所有运行容器\n\n\ndocker ps -a\n查看所有容器\n\n\ndocker exec -it 容器 bash\n进入容器\n\n\ndocker rm 容器\n删除容器，要先关闭容器才能删\n\n\ndocker stop 容器\n停止容器\n\n\ndocker start 容器\n启动容器\n\n\ndocker restart 容器\n重启容器\n\n\ndocker cp 宿主机目录 容器名称:&#x2F;容器里文件\n复制宿主机文件，到容器\n\n\ndocker cp 容器名称:&#x2F;容器文件 宿主机目录\n复制容器文件，到宿主机\n\n\ndocker -v 本地文件:&#x2F;容器文件\n映射文件，宿主机容器文件同步\n\n\ndocker logs 容器\n查看容器日志\n\n\n安装ubuntu12345678910111213141516171819201、若安装过先删除，若无忽略sudo apt-get remove docker docker-engine docker.io2、安装扩展sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common3、信任 GPGcurl -fsSL https://mirrors.huaweicloud.com/docker-ce/linux/debian/gpg | sudo apt-key add -4、添加仓库sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.huaweicloud.com/docker-ce/linux/debian $(lsb_release -cs) stable&quot;5、安装apt install docker-ce6、以上还没安装好，那肯定要这样了wget https://mirrors.huaweicloud.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmapt install containerd.io-1.2.6-3.3.el7.x86_64.rpmapt install docker-ce\n\ncentos1234567891011121314151617181920211、若安装过先删除，若无忽略sudo yum remove docker docker-common docker-selinux docker-engine2、安装扩展sudo yum install -y yum-utils device-mapper-persistent-data lvm23、下载 repo 文件wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.huaweicloud.com/docker-ce/linux/centos/docker-ce.repo4、软件仓库地址替换为：sudo sed -i &#x27;s+download.docker.com+mirrors.huaweicloud.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo5、更新索引文件并安装sudo yum makecache fastsudo yum install docker-ce6、以上还没安装好，那肯定要这样了wget https://mirrors.huaweicloud.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install docker-ce\n\n切换国内源1234567891011121、编辑配置文件vim /etc/docker/daemon.json2、添加中科大源&#123;  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]&#125;# 如果 etc/docker 下不存在 daemon.json，新建一个即可3、重启 dockersystemctl restart docker\n\n容器互联早期容器之间的互联都是使用 –link 连接，现在不在推荐使用。随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 –link 参数。\n查看网络1docker network ls\n\n\n\n\n网络类型\n描述\n特点\n\n\n\nbridge\n所有 Docker 安装中都存在的默认网络，表示为 docker0 网络。除非使用 docker run --net=选项另行指定，否则 Docker 守护进程默认会将容器连接到此网络。在主机上使用 ifconfig命令可以看到此网桥是主机的网络堆栈的一部分。\n- 提供了隔离性，每个容器拥有自己的网络命名空间。\n\n\n\n容器之间可以相互通信，但默认情况下与主机之间是相互隔离的。\nDocker 容器之间可以使用容器名称进行通信。 || none | 在容器上添加了一个特定于容器的网络堆栈，该容器缺少网络接口。 | - 容器没有网络接口，因此无法与外部通信，除非手动配置网络。\n适用于一些特殊场景，例如需要完全隔离的容器或测试场景。 || host | 在主机网络堆栈上添加一个容器，容器中的网络配置与主机相同。 | - 容器与主机共享网络命名空间，因此容器可以直接访问主机的网络接口和端口。\n容器无需进行网络地址转换（NAT），因此网络性能较高。\n容器之间无法相互访问，除非在主机上进行端口映射。 |\n\n创建网络1docker network create -d bridge 网络名称\n\nPHP 开发套件PHP拉取镜像1docker pull php:fpm\n\n创建容器1docker run --name php -p 9000:9000 --network name -v /宿主机存放代码的目录:/var/www/html -it -d php:fpm\n\n\n\n\n命令\n命令详解\n\n\n\nrun\n创建一个容器\n\n\n–name\n指定容器名称，为空 docker 自动分配名称\n\n\n-p\n端口映射，将容器的 9000 端口映射到主机的 9000 端口\n\n\n–network\n选择网络\n\n\n-v\n映射文件，宿主机容器文件同步\n\n\n-it\n表示让容器的标准输入打开,并且分配一个伪终端\n\n\n-d\n后台运行容器\n\n\n基本配置12345678910111213141516171819202122232425262728# 进入容器docker exec -it php bash# 中科大源,然后下载需要的软件sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.listapt update# Composer 安装1、curl -sS https://getcomposer.org/installer | php2、mv composer.phar /usr/local/bin/composer3、composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/# 修改 /usr/local/etc/php-fpm.conf include 路径include=/usr/local/etc/php-fpm.d/*.conf# 开启扩展命令/usr/local/bin/docker-php-ext-install mysqli# 常见的一些扩展可以这样安装了，没有的就得自己下载安装了。下载扩展到 /usr/src/php/ext 目录当中,注意：如果没有 /usr/src/php/ext 别慌执行一下 /usr/local/bin/docker-php-ext-install 一个没有的扩展，然后文件夹就会有了，每次安装好扩展之后 php 自动删除！# 关闭扩展命令docker-php-ext-enable mysqli# php.ini这个镜像给我们打包的配置文件，分开发和生产二个配置文件，在 /usr/local/etc/php 当中# 重启容器docker restart php\n\nMySQL如果是真实线上的项目，不推荐安装在容器当中，应当使用网络版本的 MySQL 本地开发无关紧要。\n拉取镜像1docker pull mysql\n\n创建容器1docker run -p 3306:3306 --name mysql --network name -v /xxx:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d --privileged=true mysql\n\n\n\n\n命令\n命令详解\n\n\n\nrun\n创建一个容器\n\n\n–name\n指定容器名称，为空 docker 自动分配名称\n\n\n-v\n映射文件，宿主机容器文件同步\n\n\n-p\n端口映射，将容器的 3306 端口映射到主机的 3306 端口\n\n\n-e\n设置环境变量，初始化 Mysql 密码\n\n\n-d\n后台运行容器\n\n\n–privileged&#x3D;true\n可能会碰到权限问题，需要加参数\n\n\n基本配置12345678910111213141516171819202122# 进入容器docker exec -it mysql bash # 更换软件源，中科大源sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.listapt update# 修改密码认证 mysql 8 加密方式改变了mysql&gt;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;root&#x27;;mysql&gt;flush privileges;# 如果需要创建一个帐号，并且赋予权限，不需要忽略mysql&gt;create user &#x27;用户名&#x27;@&#x27;访问主机&#x27; identified by &#x27;密码&#x27;;mysql&gt;grant 权限 on *.* to &#x27;帐号&#x27;@&#x27;%&#x27; WITH GRANT OPTION;# 修改 /etc/mysql/conf.d 下面的 mysql.cnf 添加以下配置，没有就创建 mysql.cnf[mysqld]port=3306default_authentication_plugin=mysql_native_password# 重启容器docker restart mysql\n\nNginx拉取镜像1docker pull nginx\n\n创建容器1docker run --name nginx -p 80:80 --network name -v /宿主机存放代码的目录:/usr/share/nginx/html -d nginx\n\n\n\n\n命令\n命令详解\n\n\n\nrun\n创建一个容器\n\n\n–name\n指定容器名称，为空 docker 自动分配名称\n\n\n-p\n端口映射，将容器的 80 端口映射到主机的 80 端口\n\n\n–network\n选择网络\n\n\n-v\n映射文件，宿主机容器文件同步\n\n\n-d\n后台运行容器\n\n\n基本配置1234567891011121314151617181920212223242526272829303132333435363738394041# 中科大源,然后下载需要的软件sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.listapt update# 贴上我的配置，Nginx 配置文件所在目录 /etc/nginxserver &#123;    # 监听端口    listen       80;    # 域名    server_name  dev.test;    # 程序目录    root   /usr/share/nginx/html/dao/public;    # 默认访问    index  index.php;    # 字符集编码    charset utf-8;    # 错误日志    access_log  /var/log/nginx/app.access.log  main;    # 默认请求 正则匹配    location / &#123;        try_files $uri $uri/ /index.php?$query_string;    &#125;    # 正则匹配到 PHP 文件请求 ，扔给 FastCGI     location ~ \\.php$ &#123;        root           /var/www/html/dao/public;        fastcgi_pass   php-fpm:9000;        fastcgi_index  index.php;        include        fastcgi_params;        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;    &#125;&#125;# 重启 nginxdocker restart nginx\n\nRedis如果是真实线上的项目，不推荐安装在容器当中，应当使用网络版本的 redis 本地开发无关紧要。\n拉取镜像1docker pull redis\n\n创建容器1docker run --name redis -p 6379:6379 --network name -d redis redis-server --appendonly yes --requirepass &quot;mypassword&quot;\n\nMemcached如果是真实线上的项目，不推荐安装在容器当中，应当使用网络版本的 memcached 本地开发无关紧要。\n拉取镜像1docker pull memcached\n\n创建容器1docker run --name memcached -p 11211:11211 -m 64m -d memcached\n\nDockerfileDockerfile 是一个文本文件，包含了一系列用于构建 Docker 镜像的指令和配置。通过 Dockerfile，开发者可以定义镜像中的环境、依赖项、运行时配置等内容，以及如何构建和配置容器。简单点来说就是创建自定义镜像，Dockerfile 一般搭配着项目的 CI&#x2F;CD 一起出现。\n常用命令\n\n\n命令\n说明\n\n\n\nFROM\n指定基础镜像\n\n\nMAINTAINER\n指定镜像维护者的信息\n\n\nRUN\n在镜像中执行命令\n\n\nCMD\n容器启动后默认执行的命令\n\n\nENTRYPOINT\n容器启动时执行的命令\n\n\nCOPY\n将文件复制到镜像中\n\n\nADD\n类似于 COPY，但功能更强大，可以自动解压缩文件和 URL\n\n\nWORKDIR\n设置工作目录\n\n\nENV\n设置环境变量\n\n\nEXPOSE\n声明容器运行时需要暴露的端口\n\n\nVOLUME\n创建一个挂载点，用于持久化数据\n\n\nUSER\n指定容器运行时的用户名或 UID\n\n\nARG\n定义构建时的参数\n\n\nONBUILD\n定义触发器指令，会在后续构建过程中被触发执行\n\n\nQt 成品 Dockerfilex86 交叉 FTD2000（ARM64）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374FROM ubuntu:16.04ENV DEBIAN_FRONTEND noninteractiveRUN sed -i &#x27;1 i deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;2 i deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;3 i deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;4 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;5 i deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;6 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;7 i deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;8 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&#x27; /etc/apt/sources.listRUN apt update &amp;&amp; apt install -y build-essential wget curl cmake python gperf bison flex pkg-configWORKDIR /optRUN apt install -y xz-utils &amp;&amp; wget -q 工具链：gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz &amp;&amp; \\    xz -d gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz &amp;&amp; \\    tar -xf gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar &amp;&amp; \\    mv gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu ./aarch64-linux-gnu &amp;&amp; \\    rm -rf gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tarENV PATH=$PATH:/opt/aarch64-linux-gnu/binRUN wget -q 地址：llvm-7.0.1.tar.gz &amp;&amp; \\    tar -xf llvm-7.0.1.tar.gz &amp;&amp; \\    rm -rf llvm-7.0.1.tar.gzRUN wget -q https://download.qt.io/archive/qt/5.12/5.12.12/single/qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    xz -d qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    tar -xf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    rm -rf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    cd qt-everywhere-src-5.12.12 &amp;&amp; \\    mkdir buildWORKDIR /sysrootRUN wget -q 打包好的 sysroot：/FTD2000.tar.gz &amp;&amp; \\    tar -zxf FTD2000.tar.gz &amp;&amp; \\    rm -rf FTD2000.tar.gzRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    sed -e &#x27;1163 s|^|//|&#x27; -i /opt/llvm-7.0.1/llvm/projects/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cc &amp;&amp; \\    cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/x86-llvm -DLLVM_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install &amp;&amp; cp /opt/llvm-7.0.1/llvm/build/bin/clang-tblgen /opt/x86-llvm/binRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ cmake -G &quot;Unix Makefiles&quot; --enable-targets=aarch64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/arm-llvm -DLLVM_TABLEGEN=/opt/x86-llvm/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/x86-llvm/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF -DCMAKE_SYSROOT=/sysroot .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install     RUN cp /sysroot/usr/lib/libstdc++.so.6.0.22 /opt/arm-llvm/lib &amp;&amp; cd /opt/arm-llvm/lib &amp;&amp; ln -s libstdc++.so.6.0.22 libstdc++.so.6 RUN cd /opt &amp;&amp; tar -zcf llvm.tar.gz arm-llvm &amp;&amp; rm -rf /opt/arm-llvm/bin &amp;&amp; cp -r /opt/x86-llvm/bin /opt/arm-llvm &amp;&amp; rm -rf /opt/llvm-7.0.1ENV LLVM_INSTALL_DIR=/opt/x86-llvmRUN cd /opt/qt-everywhere-src-5.12.12/build &amp;&amp; /opt/qt-everywhere-src-5.12.12/configure -prefix /qt5.12.12 \\    -opensource \\    -confirm-license \\    -release \\    -xplatform linux-aarch64-gnu-g++ \\    -make libs \\    -make tools \\    -nomake tests \\    -nomake examples \\    -qt-zlib \\    -sysroot /sysroot &amp;&amp; make -j64 &amp;&amp; make -j64 installRUN rm -rf /opt/qt-everywhere-src-5.12.12ENV LLVM_INSTALL_DIR=/opt/arm-llvmENV QTC_ENABLE_CLANG_LIBTOOLING=trueENV PATH=$PATH:/sysroot/qt5.12.12/bin\n\nx86 交叉 龙芯3A4000（mips64）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869FROM ubuntu:18.04ENV DEBIAN_FRONTEND noninteractiveRUN apt update &amp;&amp; apt install -y build-essential wget curl cmake python gperf bison flex pkg-config gcc-8-mips64el-linux-gnuabi64 g++-8-mips64el-linux-gnuabi64RUN rm -rf /usr/mips64el-linux-gnuabi64/lib &amp;&amp; rm -rf /usr/mips64el-linux-gnuabi64/lib64WORKDIR /optRUN wget -q 地址：llvm-7.0.1.tar.gz &amp;&amp; \\    tar -xf llvm-7.0.1.tar.gz &amp;&amp; \\    rm -rf llvm-7.0.1.tar.gzRUN wget -q https://download.qt.io/archive/qt/5.12/5.12.12/single/qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    xz -d qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    tar -xf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    rm -rf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    cd qt-everywhere-src-5.12.12 &amp;&amp; mkdir build    WORKDIR /sysrootRUN wget -q 打包好的 sysroot：jari-works-3a4000-system-usr.tar &amp;&amp; \\    tar -xf jari-works-3a4000-system-usr.tar &amp;&amp; \\    rm -rf jari-works-3a4000-system-usr.tarRUN wget -q 打包好的 sysroot：jari-works-3a4000-system-lib.tar.tar.gz &amp;&amp; \\    tar -zxf jari-works-3a4000-system-lib.tar.tar.gz &amp;&amp; \\    rm -rf jari-works-3a4000-system-lib.tar.tar.gzRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/x86-llvm -DLLVM_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install &amp;&amp; cp /opt/llvm-7.0.1/llvm/build/bin/clang-tblgen /opt/x86-llvm/binRUN rm -rf /sysroot/usr/bin &amp;&amp; cd /opt/llvm-7.0.1/llvm &amp;&amp; rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    CC=mips64el-linux-gnuabi64-gcc-8 CXX=mips64el-linux-gnuabi64-g++-8 cmake -G &quot;Unix Makefiles&quot; --enable-targets=mips -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/mips-llvm -DLLVM_TABLEGEN=/opt/x86-llvm/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/x86-llvm/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF -DCMAKE_SYSROOT=/sysroot .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install    RUN cd /opt &amp;&amp; tar -zcf llvm.tar.gz mips-llvm &amp;&amp; rm -rf /opt/mips-llvm/bin &amp;&amp; cp -r /opt/x86-llvm/bin /opt/mips-llvm &amp;&amp; rm -rf /opt/llvm-7.0.1ENV LLVM_INSTALL_DIR=/opt/x86-llvmRUN cd /opt/qt-everywhere-src-5.12.12/build &amp;&amp; cp -r /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-aarch64-gnu-g++ /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-mips64el-gnu-g++ &amp;&amp; \\    sed -i &#x27;14c QMAKE_CC          = mips64el-linux-gnuabi64-gcc-8&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;15c QMAKE_CXX         = mips64el-linux-gnuabi64-g++-8&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;16c QMAKE_LINK        = mips64el-linux-gnuabi64-g++-8&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;17c QMAKE_LINK_SHLIB  = mips64el-linux-gnuabi64-g++-8&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;20c QMAKE_AR          = mips64el-linux-gnuabi64-ar cqs&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;21c QMAKE_OBJCOPY     = mips64el-linux-gnuabi64-objcopy&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;22c QMAKE_NM          = mips64el-linux-gnuabi64-nm -P&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;23c QMAKE_STRIP       = mips64el-linux-gnuabi64-strip&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    /opt/qt-everywhere-src-5.12.12/configure -prefix /qt5.12.12 \\    -opensource \\    -confirm-license \\    -release \\    -xplatform linux-mips64el-gnu-g++ \\    -make libs \\    -make tools \\    -nomake tests \\    -nomake examples \\    -qt-zlib \\    -sysroot /sysroot &amp;&amp; \\    make -j64 &amp;&amp; make -j32 installRUN rm -rf /opt/qt-everywhere-src-5.12.12ENV LLVM_INSTALL_DIR=/opt/mips-llvmENV QTC_ENABLE_CLANG_LIBTOOLING=trueENV PATH=$PATH:/sysroot/qt5.12.12/bin\n\nx86 交叉 龙芯3A5000（LoongArch64）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485FROM ubuntu:18.04ENV DEBIAN_FRONTEND noninteractiveRUN sed -i &#x27;1 i deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;2 i deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;3 i deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;4 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;5 i deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;6 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;7 i deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;8 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&#x27; /etc/apt/sources.listRUN apt update &amp;&amp; apt install -y build-essential wget curl cmake python gperf bison flex pkg-configWORKDIR /optRUN wget -q 地址：llvm-7.0.1.tar.gz &amp;&amp; \\    tar -xf llvm-7.0.1.tar.gz &amp;&amp; \\    rm -rf llvm-7.0.1.tar.gzRUN wget http://ftp.loongnix.cn/toolchain/gcc/release/loongarch/gcc8/toolchain-loongarch64-linux-gnu-cross-830-rc1.0-2022-04-22.tar.xz &amp;&amp; \\    tar -xf toolchain-loongarch64-linux-gnu-cross-830-rc1.0-2022-04-22.tar.xz &amp;&amp; \\    rm -rf toolchain-loongarch64-linux-gnu-cross-830-rc1.0-2022-04-22.tar.xz &amp;&amp; \\    mv toolchain-loongarch64-linux-gnu-cross-830-rc1.0-2022-04-22 loongaarchENV PATH=$PATH:/opt/loongaarch/binRUN wget https://download.qt.io/archive/qt/5.12/5.12.12/single/qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    xz -d qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    tar -xf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    rm -rf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    sed -i &#x27;493c u.asBits.payload = reinterpret_cast&lt;int64_t&gt;(ptr);&#x27; /opt/qt-everywhere-src-5.12.12/qtscript/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.h &amp;&amp; \\    sed -i &#x27;505c u.asBits.payload = reinterpret_cast&lt;int64_t&gt;(const_cast&lt;JSCell*&gt;(ptr));&#x27; /opt/qt-everywhere-src-5.12.12/qtscript/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.h &amp;&amp; \\    cd qt-everywhere-src-5.12.12 &amp;&amp; mkdir buildWORKDIR /sysrootRUN wget 打包好的 sysroot：loongson-3A5000.tar.gz &amp;&amp; \\    tar -zxf loongson-3A5000.tar.gz &amp;&amp; \\    rm -rf loongson-3A5000.tar.gzRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    sed -e &#x27;1163 s|^|//|&#x27; -i /opt/llvm-7.0.1/llvm/projects/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cc &amp;&amp; \\    cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/x86-llvm -DLLVM_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install &amp;&amp; cp /opt/llvm-7.0.1/llvm/build/bin/clang-tblgen /opt/x86-llvm/binRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    CC=loongarch64-linux-gnu-gcc CXX=loongarch64-linux-gnu-g++ cmake -G &quot;Unix Makefiles&quot; --enable-targets=loongaarch64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/loongaarch64-llvm -DLLVM_TABLEGEN=/opt/x86-llvm/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/x86-llvm/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF -DCMAKE_SYSROOT=/sysroot .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install    RUN cd /opt &amp;&amp; tar -zcf loongaarch64.tar.gz loongaarch64-llvm &amp;&amp; rm -rf /opt/loongaarch64-llvm/bin &amp;&amp; cp -r /opt/x86-llvm/bin /opt/loongaarch64-llvm &amp;&amp; rm -rf /opt/llvm-7.0.1ENV LLVM_INSTALL_DIR=/opt/x86-llvmRUN cd /opt/qt-everywhere-src-5.12.12/build &amp;&amp; cp -r /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-aarch64-gnu-g++ /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++ &amp;&amp; \\    sed -i &#x27;89c defined(__mips__) || defined(__loongarch__) || \\\\&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/src/3rdparty/double-conversion/include/double-conversion/utils.h &amp;&amp; \\    sed -i &#x27;14c QMAKE_CC          = loongarch64-linux-gnu-gcc&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;15c QMAKE_CXX         = loongarch64-linux-gnu-g++&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;16c QMAKE_LINK        = loongarch64-linux-gnu-g++&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;17c QMAKE_LINK_SHLIB  = loongarch64-linux-gnu-g++&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;20c QMAKE_AR          = loongarch64-linux-gnu-ar cqs&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;21c QMAKE_OBJCOPY     = loongarch64-linux-gnu-objcopy&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;22c QMAKE_NM          = loongarch64-linux-gnu-nm -P&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;23c QMAKE_STRIP       = loongarch64-linux-gnu-strip&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    /opt/qt-everywhere-src-5.12.12/configure -prefix /qt5.12.12 \\    -opensource \\    -confirm-license \\    -release \\    -xplatform linux-loongarch64-gnu-g++ \\    -make libs \\    -make tools \\    -nomake tests \\    -nomake examples \\    -qt-zlib \\    -xcb-xlib -xcb \\    -opengl desktop \\    -sysroot /sysroot &amp;&amp; \\    make -j64 &amp;&amp; make -j32 installRUN rm -rf /opt/qt-everywhere-src-5.12.12ENV LLVM_INSTALL_DIR=/opt/loongaarch64-llvmENV QTC_ENABLE_CLANG_LIBTOOLING=trueENV PATH=$PATH:/sysroot/qt5.12.12/bin","slug":"Docker","date":"2024-02-22T08:03:32.000Z","categories_index":"","tags_index":"Docker","author_index":"哪吒"},{"id":"425d803af0b4bf31b2b7e015a65ed6f3","title":"会话技术","content":"\n\n\n\n\n\n\n\n\n💡 Tips：HTTP 的一大特点“无状态”，是其最初版本的设计特点之一，而这一特点一直保持到 HTTP 的最新版本。无状态意味着每个请求之间是相互独立的，服务器不会保存关于客户端请求的任何信息。这意味着每个请求都需要包含所有必要的信息，因此服务器可以理解并响应。\n虽然 HTTP 的无状态特性一直是保留下来的核心概念，但是随着时间的推移，HTTP 协议的演变和发展已经引入了一些机制来处理状态信息，比如 Cookie、Session 等机制。这些机制允许服务器和客户端在一系列请求之间共享状态信息，从而实现了在无状态协议中模拟有状态的行为。\n总的来说，尽管 HTTP 协议的基本无状态特性一直保持着，但随着技术的发展和需求的变化，HTTP 协议的实现和使用中引入了许多额外的功能和机制来处理状态信息，以满足现代网络应用的需求。\nCookieCookie 是客户端使用的一种记录客户端状态的机制，是由 W3C 组织提出，最早由 Netscape(网景) 社区发展的一种机制。目前 Cookie 已经成为标准，所有的主流浏览器基本都支持 Cookie。\nCookie 工作流程Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上：\n\n\n\n\n\n\n\n\n\n\n\n\n服务器端设置 Cookie： 当客户端向服务器发送请求时，服务器可以在 HTTP 响应消息报头中插入 Set-Cookie 标头，以设置 Cookie。Set-Cookie 标头包含了 Cookie 的名称、值以及其他可选的属性，如过期时间、域、路径等；\n客户端保存 Cookie： 客户端收到服务器发送的响应后，会将其中的 Set-Cookie 标头中的 Cookie 保存起来。如果 Cookie 设置了过期时间，那么它将会被持久地存储，直到到达过期时间；如果没有设置过期时间，那么它将只在客户端的内存中存储，并在关闭浏览器时被删除；\n客户端发送 Cookie： 当客户端向服务器发送新的请求时，它会自动在请求报头中插入所有与当前域相关联的 Cookie；\n服务器端读取 Cookie： 服务器收到客户端的请求后，可以通过读取请求报头中的 Cookie 来获取客户端发送的数据。服务器可以根据这些 Cookie 来识别用户状态、执行个性化操作等；\n\nCookie 应用场景\n个性化设置：如用户自定义设置、主题等；\n浏览器行为跟踪：如跟踪分析用户行为等；\n会话状态管理：如用户登录状态、购物车、游戏分数或其它需要记录的信息；\n\nCookie 一些细节\n\n\n\n\n\nTIP\n\n持久存储的 Cookie： 存储在客户端的磁盘上，因此可以在浏览器会话之间持续存在，即使关闭浏览器再打开也会继续存在。这种类型的 Cookie 可以通过设置过期时间来控制其持续时间，但它们不会跨越浏览器或设备边界，因为它们存储在本地文件系统中，每个浏览器和设备都有自己的本地文件系统，但通过 Cookie 导出导入可以做到跨浏览器和设备；\n非持久存储的 Cookie： 存储在客户端的内存中，通常在关闭浏览器时就会被销毁。这种 Cookie 通常用于临时性数据的存储，比如会话标识符等。因为它们只存储在内存中，并且会在浏览器关闭时被销毁，所以不能持久存在，也不会跨越浏览器或设备边界；\n存储大小限制： 每个 Cookie 的存储大小通常限制在 4KB 左右。这意味着单个 Cookie 的键值对及其相关的元数据（如过期时间、域、路径等）总共不能超过这个大小；\n最大 Cookie 数量限制： 一个浏览器通常会限制每个域名下的 Cookie 数量，一般不超过 300 个 Cookie。这个限制旨在防止网站过度使用 Cookie，以及减轻客户端存储的压力；\n单个网站 Cookie 数量限制：每个网站最多可以设置的 Cookie 数量通常也有限制，一般不超过 20 个。这个限制有助于确保网站不会过度依赖 Cookie 来存储大量数据，以及减少客户端存储的负担；\nCookie 同源策略：Cookie 同源策略允许在同一父级域名下共享 Cookie。这意味着当设置了一个 Cookie 的 “domain” 属性时，该 Cookie 将在指定的域名以及其所有的子域名下可见。因此，当访问子域名时，浏览器会发送父级域名下的 Cookie，使得跨子域名间可以共享用户状态信息；\n\n\n\nSessionSession 是一种服务器端的状态管理机制，用于存储和跟踪用户的会话信息。与 Cookie 不同，Session 数据存储在服务器端，而不是客户端。\nSession 工作流程Session 与 Cookie 有很大的相似，服务端最终响应给客户端的是一段 Cookie，从而可以说 Session 的实现依赖 Cookie：\n\n\n\n\n\n\n\n\n\n\n\n\n服务器创建 Session： 服务器为用户创建一个新的 Session，并生成一个唯一的 SessionID；\n发送 SessionID 给客户端： 服务器将 SessionID 放置在 Set-Cookie 标头中发送给客户端；\n客户端保存 SessionID： 客户端（浏览器）保存接收到的 SessionID；\n客户端发送请求并携带 SessionID： 客户端发送请求时，自动将保存的 SessionID 放置在请求的 Cookie 中发送给服务器；\n服务器根据 SessionID 获取数据： 服务器根据 SessionID 获取与用户相关的会话数据；\n服务器返回响应： 服务器根据请求处理结果生成响应并发送给客户端；\n\nSession 应用场景跟 Cookie 一样，没啥子差别。\nSession 一些细节\n\n\n\n\n\nTIP\n\n禁用了 Cookie 之后 Session 还可以用嘛？\nSession 实现关键是 SessionID，只需要将 SessionID 传递给浏览器，浏览器在请求的时候再将 SessionID 传递给服务器，就可以实现 Session；\n\n\n假如使用了 Nginx 服务器软件做了负载均衡，那么会发现丢失 Session 的问题。出现丢失 Session 问题怎么办呢？\n可以使用用 Nginx ip_hash 算法解决；\n\n\n\n\n\nSession 和 Cookie 的区别\n\n\n\n\n\nTIP\n\nSession 存储在服务端，Cookie 存储在客户端；\nSession 用户无法查看和修改，Cookie 用户可以查看修改；\nSession 和 Cookie 的存储容量不同，Cookie 有各种限制，Session 没有限制；\n\n\n\n","slug":"会话技术","date":"2024-02-22T05:56:20.000Z","categories_index":"","tags_index":"网络协议","author_index":"哪吒"},{"id":"44a298e41e961f01947480950600547b","title":"搞定 HTTP 协议","content":"\n\n\n\n\n\n\n\n\n💡 Tips：HTTP 协议（超文本传输协议 HyperText Transfer Protocol），是一种基于 TCP&#x2F;IP 协议的应用层协议，用于在客户端和服务器之间传输超文本文档，超文本文档可以包含各种内容：文本、图形、音频、视频、二进制文件等。\n历史版本\n\n\n\n\n\nTIP\n\n1991 年发布的 HTTP&#x2F;0.9 版本发布，该版本及其的简单，只有一个命令 GET ，且只支持文本传输；\n1996 年 5 月份， HTTP&#x2F;1.0 版本发布，内容大大的增加。可以传输任何格式的内容：文本、图形、音频、视频、二进制文件等。命令也进行了扩展，引入了 POST 和 HEAD 命令。但 1.0 版本存在一个缺点，不支持持久连接；\n1997 年 1 月，HTTP&#x2F;1.1 版本发布，进一步的完善了 HTTP 协议，也是现目前互联网使用最广泛的版本。1.1 版本最大的变化就是引入了持久连接；\n2015 年，HTTP&#x2F;2 发布。它不叫 HTTP&#x2F;2.0，因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP&#x2F;3 。3 版本的最大的改变，可能会抛弃掉 TCP 协议使用 UDP 协议；\n\n\n\n持久化与非持久化持久化（长连接）为了解决非持久连接的缺点，HTTP&#x2F;1.1 引入了持久连接的概念。在持久连接中，客户端和服务器之间的连接在一定的时间段内保持打开状态，可以在同一连接上发送多个请求和接收多个响应。这样做可以避免重复创建和关闭连接的开销，提高通信效率和性能。持久连接使得可以在一个连接上完成多个 HTTP 请求&#x2F;响应往返。\n非持久化（短连接）在 HTTP&#x2F;1.0 版本中，每次客户端发送请求给服务器时，都会创建一个新的 TCP 连接。这个连接在请求完成后会立即关闭。也就是说，每个请求和响应都需要独立的连接，这种方式被称为非持久连接。这种方法的缺点是，每次创建和关闭连接都需要时间和资源，会增加通信的延迟和消耗。\n持久化优缺点\n优点\n减少延迟： 可以在同一连接上连续发送多个请求和接收多个响应，减少了连接建立和关闭的开销，提高了通信的效率和性能；\n节省资源： 保持连接打开可以避免重复的连接建立和关闭，节省了服务器和客户端的连接资源；\n提高吞吐量： 长连接可以在一定程度上提高系统的吞吐量，特别是在大量并发请求的情况下；\n\n\n缺点\n资源占用： 长时间保持连接打开会占用服务器和客户端的连接资源，可能会导致资源的浪费；\n管理复杂性： 长连接需要管理连接的生命周期和状态，增加了系统的管理和维护成本；\n占用连接数： 长连接会占用一定数量的连接数，可能会影响其他用户的访问和系统的可用性；\n\n\n\n非持久化优缺点\n优点\n资源释放： 每个请求完成后立即关闭连接，释放了服务器和客户端的连接资源，有助于节省资源；\n独立性： 每个请求和响应都使用独立的连接，相互独立，不会相互影响，有助于提高系统的稳定性；\n灵活性： 适用于对延迟要求严格、资源受限或需要相对独立的场景；\n\n\n缺点\n连接开销： 频繁地创建和关闭连接会增加通信的延迟和资源消耗，降低了通信的效率；\n性能下降： 每次建立连接都需要进行三次握手，增加了网络延迟，降低了性能；\n服务器负载： 大量的连接创建和关闭会增加服务器的负载，影响系统的性能和吞吐量；\n\n\n\n注意事项\n无论是持久连接还是非持久连接，在建立 TCP 连接和关闭 TCP 连接时都需要遵循 TCP 的三次握手和四次挥手过程； \nNginx 默认的持久连接超时时间为 75 秒，keepalive_timeout 可以设置持久连接的超时时间，如果客户端和服务器之间在设置的时间内没有任何活动，则 Nginx 会关闭持久连接；\n\n初识传输层协议在计算机网络中，应用层协议通常是建立在传输层协议之上的，这种关系通常被称为协议栈或协议堆叠。应用层协议利用传输层协议提供的服务来实现通信的目的。在继续深入 HTTP 协议前，有必要先看下网络组成图：\n\n\nTCP 传输控制协议\nTCP 是一种面向连接的协议，这意味着在发送数据之前，通信的两端需要建立一个连接；\n它提供可靠的数据传输，通过使用确认、重传、校验和流量控制等机制，确保数据的可靠性和完整性。如果数据在传输过程中丢失或损坏，TCP 将负责重新发送数据，直到接收到正确的数据为止；\nTCP 是一种流式协议（STREAM），数据被视为一连串的字节流，因此它保证了数据的顺序传输；\n在连接的建立和断开过程中，TCP 使用了三次握手和四次挥手的机制，以确保双方都同意建立或断开连接；\n\nUDP 用户数据协议\nUDP 是一种无连接的协议，通信的两端在传输数据之前不需要建立连接；\n它提供了一种简单的数据传输机制，不保证数据的可靠性或顺序传输。如果数据在传输过程中丢失或损坏，UDP 不会进行重传，而是直接丢弃这些数据；\nUDP 适用于一些对实时性要求高、对数据可靠性要求较低的应用，比如音频、视频传输等；\n由于不需要建立连接和维护状态信息，UDP 的开销比 TCP 小，传输速度相对更快；\n\nTCP 应用场景\n网页浏览：当你在浏览网页时，通常会使用 TCP 协议。因为网页的数据传输需要保证数据的完整性和顺序性，这样才能确保页面元素的正确加载和显示；\n电子邮件：发送和接收电子邮件时也通常使用 TCP。电子邮件的传输需要确保邮件内容的完整性，而且邮件的顺序也很重要，所以 TCP 协议是一个合适的选择。\n文件传输：在需要可靠地传输大文件的场景下，TCP 是首选。FTP（文件传输协议）等文件传输服务通常使用 TCP 协议，因为它能够确保文件的完整传输，而且对传输顺序有要求；\n远程登录：SSH（Secure Shell）等远程登录服务通常使用 TCP。远程登录需要确保传输的命令和输出是可靠的，并且需要保持会话的状态；\n\nUDP 应用场景\n实时视频&#x2F;音频传输：视频会议、在线直播等实时应用通常使用 UDP 协议。在这些应用中，实时性比数据的完整性更加重要，因此可以使用 UDP 以减少传输延迟；\n实时游戏：在线游戏通常使用 UDP 进行通信，因为在游戏中延迟是非常关键的，而 UDP 能够提供更低的传输延迟，并且允许丢失部分数据而不会导致整个通信阻塞；\nDNS（域名系统）查询：DNS 查询也常常使用 UDP 协议。虽然 DNS 查询需要准确的返回结果，但由于查询通常很小且响应时间敏感，因此 UDP 的简单性和低延迟使其成为了首选；\nSNMP（简单网络管理协议）：网络管理中的 SNMP 通常使用 UDP。尽管管理信息的准确性很重要，但由于 SNMP 的查询通常是小且频繁的，UDP 提供了更好的性能和效率；\n\n三次握手三次握手是 TCP 协议中用于建立连接的过程，确保了通信的可靠性和正确性，上图：\n\n\n\n第一次握手（SYN） \n客户端向服务器发送一个带有 SYN 标志的数据包，表示客户端请求建立连接，并指定一个初始序列号；\n\n\n第二次握手（SYN + ACK） \n服务器收到客户端的 SYN 数据包后，会发送一个带有 SYN 和 ACK 标志的数据包作为响应，表示确认收到连接请求，并且也指定一个初始序列号；\n\n\n第三次握手（ACK） \n客户端收到服务器的响应后，会发送一个带有 ACK 标志的数据包作为确认，表示确认收到服务器的响应，连接建立成功；\n\n\n\n四次挥手四次挥手是 TCP 协议中用于关闭连接的过程，确保了双方在断开连接时的可靠性，上图：\n\n\n\n第一次挥手（FIN） \n客户端向服务器发送一个带有 FIN（结束）标志的数据包，表示客户端不再发送数据，但仍然可以接收数据；\n\n\n第二次挥手（ACK） \n服务器收到客户端的 FIN 数据包后，会发送一个带有 ACK（确认）标志的数据包作为响应，表示确认收到客户端的关闭请求；\n\n\n第三次挥手（FIN） \n服务器在发送完所有数据后，会向客户端发送一个带有 FIN 标志的数据包，表示服务器也准备关闭连接；\n\n\n第四次挥手（ACK） \n客户端收到服务器的 FIN 数据包后，会发送一个带有 ACK 标志的数据包作为响应，表示确认收到服务器的关闭请求，连接关闭；\n\n\n\nTCP&#x2F;IP 通信传输流利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下：\n\n\nHTTP 工作流程当浏览器（客户端）想要获取某个站点（服务端）网页时，它会按照以下步骤执行 HTTP 工作流程：\n\n\n\n\n\n\n\n\nTIP\n\n解析URL： \n用户在浏览器中输入 URL（统一资源定位符）；\n浏览器解析 URL，提取出协议、域名和路径等信息；\n\n\nDNS解析： \n浏览器发起 DNS 解析请求，将域名解析成服务器的 IP 地址；\n浏览器获取到服务器的 IP 地址后，就可以发起与服务器的连接了；\n\n\n建立TCP连接： \n浏览器使用 HTTP 协议建立 TCP 连接到服务器；\n这是通过三次握手来建立可靠的连接；\n\n\n发送HTTP请求： \n浏览器向服务器发送 HTTP 请求；\nHTTP 请求中包含了请求的方法（GET、POST等）、请求头和请求体等信息；\n\n\n服务器处理请求： \n服务器接收到浏览器发送的 HTTP 请求后，根据请求的路径和方法等信息，处理请求；\n服务器可能会查询数据库、执行业务逻辑等，然后准备好需要发送给浏览器的 HTTP 响应；\n\n\n发送HTTP响应： \n服务器将准备好的 HTTP 响应发送给浏览器；\nHTTP 响应中包含了响应的状态码、响应头和响应体等信息；\n\n\n接收HTTP响应： \n浏览器接收到服务器发送的 HTTP 响应后，开始处理响应；\n浏览器会根据响应的内容类型等信息，决定如何处理响应；\n\n\n渲染页面： \n如果响应的内容是 HTML 页面，浏览器会解析 HTML 代码，并根据 CSS 样式表和 JavaScript 脚本等进行页面布局和渲染；\n如果接收的 HTTP 响应是 API 接口响应。浏览器不需要渲染 HTML 页面，而是处理接收到的 JSON 或其他数据格式的响应，然后根据前端逻辑进行相应的处理；\n浏览器会将渲染后的页面呈现给用户，用户就可以在浏览器中看到网页内容了；\n\n\n关闭连接： \n当页面加载完成后，浏览器会关闭与服务器的 TCP 连接，释放资源；\n\n\n\n\n\n什么是 HTTP 事务？一次 HTTP 完整的工作流程步骤很多，重点关注在于请求与响应组合而成的 HTTP 事务。HTTP 事务 &#x3D; 请求命令 + 响应结果。简单说就是一次完整的请求过程，包括请求的发送和结果的返回，如果只有发送请求，而没有响应结果，则不能算作 HTTP 事务。\nHTTP 请求123456789POST /submit-form HTTP/1.1ost: www.example.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: en-US,en;q=0.9Content-Type: application/x-www-form-urlencodedContent-Length: 29username=user&amp;password=pass123\n\n\n\n\n\n\n\n\n\n\n请求报文可以分为三部分：\n\n请求行（Request Line）包括请求的命令、资源的路径和协议版本；\n请求头部（Request Headers）包括了一系列的键值对，用来描述请求的一些附加信息；\n请求体（Request Body）对于 GET 请求，通常为空，因为 GET 请求不包含请求体。对于其他一些请求方法（如POST、PUT等），请求体可能包含一些自定义数据或内容；\n\n请求命令\n\n\n命令\n描述\n\n\n\nGET\n请求指定的页面信息，并返回实体主体\n\n\nPOST\n向指定资源提交数据进行处理请求\n\n\nPUT\n向指定资源位置上传新的实体主体\n\n\nDELETE\n请求服务器删除指定的页面\n\n\nHEAD\n类似于GET请求，只不过返回的响应中没有具体的内容，用于获取资源的元信息\n\n\nPATCH\n对资源进行部分修改\n\n\nOPTIONS\n请求服务器告知其支持的HTTP方法\n\n\n请求头\n\n\nHeader\n描述\n示例\n\n\n\nAccept\n告诉服务器，客户端支持的数据类型。\nAccept: text&#x2F;plain, text&#x2F;html\n\n\nAccept-Charset\n告诉服务器，客户端采用的编码。\nAccept-Charset: iso-8859-5,utf-8\n\n\nAccept-Encoding\n告诉服务器，客户机支持的数据压缩格式。\nAccept-Encoding: compress, gzip\n\n\nAccept-Language\n告诉服务器，客户机的语言环境。\nAccept-Language: en,zh\n\n\nAccept-Ranges\n可以请求网页实体的一个或者多个子范围字段\nAccept-Ranges: bytes\n\n\nAuthorization\nHTTP授权的授权证书类型\nAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;\n\n\nCache-Control\n指定请求和响应遵循的缓存机制\nCache-Control: no-cache\n\n\nConnection\n表示是否需要持久连接（HTTP 1.1默认进行持久连接）\nKeep-Alive\n\n\nCookie\nHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器\nCookie: $Version&#x3D;1; Skin&#x3D;new;\n\n\nContent-Length\n请求的内容长度\nContent-Length: 348\n\n\nContent-Type\n请求的与实体对应的MIME信息\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\nDate\n请求发送的日期和时间\nDate: Tue, 15 Nov 2010 08:12:31 GMT\n\n\nExpect\n请求的特定的服务器行为\nExpect: 100-continue\n\n\nFrom\n发出请求的用户的Email\nFrom: xxx@163.com\n\n\nHost\n指定请求的服务器的域名和端口号\nHost: www.baidu.com\n\n\nIf-Match\n只有请求内容与实体相匹配才有效\nIf-Match: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Modified-Since\n客户机通过这个头告诉服务器，资源的缓存时间。\nIf-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT\n\n\nIf-None-Match\n如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变\nIf-None-Match: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Range\n如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag\nIf-Range: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Unmodified-Since\n只在实体在指定时间之后未被修改才请求成功\nIf-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT\n\n\nMax-Forwards\n限制信息通过代理和网关传送的时间\nMax-Forwards: 10\n\n\nPragma\n用来包含实现特定的指令\nPragma: no-cache\n\n\nProxy-Authorization\n连接到代理的授权证书\nProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;\n\n\nRange\n只请求实体的一部分，指定范围\nRange: bytes&#x3D;500-999\n\n\nReferer\n客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的。（一般用于防盗链）\nReferer: www.zcmhi.com/archives/71…\n\n\nTE\n客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息\nTE: trailers,deflate;q&#x3D;0.5\n\n\nUpgrade\n向服务器指定某种传输协议以便服务器进行转换（如果支持）\nUpgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11\n\n\nUser-Agent\n浏览器的具体信息\nUser-Agent: Mozilla&#x2F;5.0 (Linux; X11)\n\n\nVia\n通知中间网关或代理服务器地址，通信协议\nVia: 1.0 fred, 1.1 nowhere.com\n\n\n(Apache&#x2F;1.1)\n\n\n\n\nWarning\n关于消息实体的警告信息\nWarn: 199 Miscellaneous warning\n\n\nHTTP 响应12345678910HTTP/1.1 200 OKDate: Sat, 01 Jan 2022 12:00:00 GMTServer: Apache/2.4.41 (Unix)Content-Type: application/jsonContent-Length: 56&#123;    &quot;message&quot;: &quot;Hello, world!&quot;,    &quot;status&quot;: &quot;success&quot;&#125;\n\n\n\n\n\n\n\nTIP\n响应报文可以分为三部分：\n\n响应行（Status Line）包括了协议版本、状态码和状态消息；\n响应头部（Response Headers）包括了一系列的键值对，用来描述响应的一些附加信息；\n响应体（Response Body）包含了响应的实际内容；\n\n\n\n状态码\n\n\n状态码\n描述\n\n\n\n1xx\n指示信息 - 表示请求已接收，继续处理\n\n\n100\n客户必须继续发出请求。\n\n\n101\n客户要求服务器根据请求转换 HTTP 协议版本。\n\n\n2xx\n成功 - 表示请求已被成功接收、理解、接受\n\n\n200\n（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n\n\n201\n（已创建） 请求成功并且服务器创建了新的资源。\n\n\n202\n（已接受） 服务器已接受请求，但尚未处理。\n\n\n3xx\n重定向 - 要完成请求必须进行更进一步的操作\n\n\n300\n（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者选择一项操作，或提供操作列表供请求者选择。\n\n\n301\n（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。\n\n\n302\n（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n\n\n4xx\n客户端错误 - 请求有语法错误或请求无法实现\n\n\n400\n（错误请求） 服务器不理解请求的语法。\n\n\n401\n（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n\n\n403\n（禁止） 服务器拒绝请求。\n\n\n5xx\n服务器端错误 - 服务器未能实现合法的请求\n\n\n500\n（服务器内部错误） 服务器遇到错误，无法完成请求。\n\n\n501\n（尚未实施） 服务器不具备完成请求的功能。\n\n\n502\n（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n\n\n503\n（服务不可用） 服务器目前无法使用。 通常，这只是暂时状态。\n\n\n504\n（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n\n\n505\n（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\n\n\n响应头\n\n\nHeader\n描述\n示例\n\n\n\nAccept-Ranges\n表明服务器是否支持指定范围请求及哪种类型的分段请求\nAccept-Ranges: bytes\n\n\nAge\n从原始服务器到代理缓存形成的估算时间（以秒计，非负）\nAge: 12\n\n\nAllow\n对某网络资源的有效的请求行为，不允许则返回405\nAllow: GET, HEAD\n\n\nCache-Control\n告诉所有的缓存机制是否可以缓存及哪种类型\nCache-Control: no-cache\n\n\nContent-Encoding\nweb服务器支持的返回内容压缩编码类型。\nContent-Encoding: gzip\n\n\nContent-Language\n响应体的语言\nContent-Language: en,zh\n\n\nContent-Length\n响应体的长度\nContent-Length: 348\n\n\nContent-Location\n请求资源可替代的备用的另一地址\nContent-Location: &#x2F;index.htm\n\n\nContent-MD5\n返回资源的MD5校验值\nContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ&#x3D;&#x3D;\n\n\nContent-Range\n在整个返回体中本部分的字节位置\nContent-Range: bytes 21010-47021&#x2F;47022\n\n\nContent-Type\n如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码\nContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n\nDate\n原始服务器消息发出的时间\nDate: Tue, 15 Nov 2010 08:12:31 GMT\n\n\nETag\n请求变量的实体标签的当前值\nETag: “737060cd8c284d8af7ad3082f209582d”\n\n\nExpires\n响应过期的日期和时间\nExpires: Thu, 01 Dec 2010 16:00:00 GMT\n\n\nLast-Modified\n请求资源的最后修改时间\nLast-Modified: Tue, 15 Nov 2010 12:45:26 GMT\n\n\nLocation\n用来重定向接收方到非请求URL的位置来完成请求或标识新的资源\nLocation: http://www.zcmhi.com/archives/94.html\n\n\nPragma\n包括实现特定的指令，它可应用到响应链上的任何接收方\nPragma: no-cache\n\n\nProxy-Authenticate\n它指出认证方案和可应用到代理的该URL上的参数\nProxy-Authenticate: Basic\n\n\nrefresh\n应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）\nRefresh: 5; url&#x3D;http://www.zcmhi.com/archives/94.html\n\n\nRetry-After\n如果实体暂时不可取，通知客户端在指定时间之后再次尝试\nRetry-After: 120\n\n\nServer\nweb服务器软件名称\nServer: Apache&#x2F;1.3.27 (Unix) (Red-Hat&#x2F;Linux)\n\n\nSet-Cookie\n设置Http Cookie\nSet-Cookie: UserID&#x3D;JohnDoe; Max-Age&#x3D;3600; Version&#x3D;1\n\n\nTrailer\n指出头域在分块传输编码的尾部存在\nTrailer: Max-Forwards\n\n\nTransfer-Encoding\n文件传输编码\nTransfer-Encoding:chunked\n\n\nVary\n告诉下游代理是使用缓存响应还是从原始服务器请求\nVary: *\n\n\nVia\n告知代理客户端响应是通过哪里发送的\nVia: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1)\n\n\nWarning\n警告实体可能存在的问题\nWarning: 199 Miscellaneous warning\n\n\nWWW-Authenticate\n表明客户端请求实体应该使用的授权方案\nWWW-Authenticate: Basic\n\n\n","slug":"搞定 HTTP 协议","date":"2024-02-18T09:19:57.000Z","categories_index":"","tags_index":"网络协议","author_index":"哪吒"}]