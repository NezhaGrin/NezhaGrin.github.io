[{"id":"221a7ad001c03569112f684b2dfdc120","title":"Git","content":"\n\n\n\n\n\n\n\n\n💡 Tips：git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。\ngit 与 github 什么关系？git 只是一个工具，而 github 是一个代码托管的仓库。仓库还是推荐 gitlab 私有化部署而且它的 CI&#x2F;CD 也非常的强大。\n初始化12git config --global user.name  &quot;your user name&quot;git config --global user.email &quot;your email&quot;\n\n\n\n\n\n\n\nTIP\n首次安装 git 后的初始化命令。\n\n生成秘钥12# 生成密钥，连续三下空格ssh-keygen -t rsa -b 4096 -C &quot;your email&quot;\n\n克隆项目1git clone [-b 分支] 项目地址\n\n须知知识工作区工作区是当前正在工作的目录，其中包含了项目的实际文件。编辑文件、添加新文件、删除文件等操作的地方。在工作区中进行的所有更改都可以通过 git 跟踪。\n查看状态12# 可以看见工作区的：增、删、改git status\n\n抛弃更改12# 无法抛弃增加git checkout . 或 文件地址 // . 代表所有\n\n暂存区暂存区是一个中间区域，用于暂时存放即将提交到版本库的更改。可以通过 git add 命令将工作区中的文件添加到暂存区，准备提交到版本库。\n添加到暂存区1git add . 或 文件地址 // . 代表所有\n\n取消暂存1git restore --staged . 或 文件地址 // . 代表所有\n\n版本库版本库是 git 存储项目历史记录的地方，它包含了项目的所有版本和元数据。版本库通常位于项目的 .git 目录中。当执行 git commit 命令时，git 会将暂存区中的内容提交到版本库中，形成一个新的提交。\n提交版本库1git commit -m &#x27;操作备注&#x27; // 操作备注是个好习惯，一定要注释详细\n\n回滚123456789101112131415# 查看日志，查看日志后按 q 才能退出日志git log     # 常用命令一：比较暴力，重置 HEAD、索引和工作区git reset --herd CommitID           // 回滚到指定的版本git reset --hard HEAD^             // 回退到上个版本git reset --hard HEAD~3           // 回退到前 3 次提交之前，以此类推，回退到 n 次提交之前# 常用命令二：稍微温柔，重置 HEAD，HEAD 表示的是当前指针指向git reset --soft CommitID# 其他命令    --mixed               重置 HEAD 和索引到暂存区    --merge               重置 HEAD 索引和工作区    --keep                重置 HEAD 但保存本地变更\n\n入库流程1234567891011121314# 查看状态，工作区git status# 提交到暂存区git add . 或 文件地址 // . 代表所有# 提交版本库，对外不可见，本地仓库git commit -m &#x27;操作备注&#x27; // 操作备注是个好习惯，一定要注释详细# 拉取更新，以防冲突git pull origin [分支]# 最终入库，这一步一定要确认正确无误！对外可见git push origin [分支]\n\n\n\n\n\n\n\nTIP\ngit commit -m 的时候，养成一个良好的习惯，遵循一下提交备注规范：\n\nfeat：新功能；\nfix：修复 bug，携带上出现 bug 的 commit ID 最好；\ndocs：文档；\nstyle：格式；\nrefactor：重构，即不是新增功能，也不是修改 bug 的代码变动；\nperf：优化相关，比如提升性能、体验；\ntest：增加测试；\nchore：构建过程或辅助工具的变动；\nrevert：回滚到上一个版本；\nmerge：代码合并；\nsync：同步主线或分支的 bug；\n\n\n\n分支操作查看分支12345678# 查看所有分支git branch -a# 查看远程分支git branch -r# 查看本地分支git branch\n\n创建本地分支12345# 正常创建git branch 分支名# 创建后切换git checkout -b 分支名\n\n切换本地分支1git checkout 分支\n\n创建远程分支12# 意思就是本地创建了分支，然后 push 到仓库去git push origin [分支]\n\n改变上游信息(追踪)12# 使用 git status 可以查看到当前分支的追踪的分支，使用此命令可以更改追踪git branch -u origin 分支名\n\n删除本地分支1git branch -d 分支名\n\n删除远程分支1git push --delete origin 分支名\n\n合并分支1git merge 分支名\n\n合并到主分支12345678# 切换到主分支git checkout 分支名# 养成一个良好习惯，合并前先拉取最新git pull# 合并git merge 分支名\n\n仓库操作查看仓库12345# 查看这个仓库git remote # 查看详情git remote -v\n\n添加一个新的远程仓库12345678# 添加远程分支，指定远程仓库的别名git remote add 分支名 仓库地址# 更新远程跟踪分支git fetch 分支名# 改变上游git branch -u 分支名\n\n重命名远程仓库别名12# 重命名远程追踪分支git remote rename 原始分支名 新分支名\n\n移除远程仓库12# 删除远程追踪分支，删除之后追踪无效git remote remove 分支名\n\n其他操作忽略文件12# .gitignore 忽略的文件不会上传vim .gitignore\n\n删除远程仓库指定文件1234567891011# 比如项目 vendor 目录传了上去（我同事就经常这样）git rm -r --cached [文件或目录]git commit -m &#x27;备注&#x27;git push# 修改 .gitignore 忽略文件/vendor/*.*git add . git commit -m &#x27;备注&#x27;git push\n\n一个分支多个 commit 合并成一个1git rebase -i","slug":"Git","date":"2024-02-26T13:42:40.000Z","categories_index":"","tags_index":"Git","author_index":"哪吒"},{"id":"263e776b7c4ab948e2c3d7edc00d6223","title":"MySQL 读写分离","content":"\n\n\n\n\n\n\n\n\n💡 Tips：MySQL 读写分离是一种数据库架构设计模式，旨在提高数据库性能和可伸缩性。它通过将读请求和写请求分发到不同的数据库实例上来实现。\n基本原理\n主数据库（Master）：负责处理所有的写操作（INSERT、UPDATE、DELETE），以保证数据的一致性和可靠性；\n从数据库（Slave）：主要负责处理读操作（SELECT），它们的数据是通过主数据库同步复制过来的，因此数据一致性会有一定延迟；\n\n\n\n\n\n\n\nTIP\n设置主从复制（Master-Slave Replication）：在 MySQL 中配置主数据库和从数据库。主数据库持续地将其写操作的日志传输给从数据库，从数据库则执行这些写操作，以保持数据的同步。从数据库的数据同步存在一定的延迟，因此需要考虑如何处理延迟带来的数据一致性问题。一般情况下，读操作可以容忍一定的延迟，但对于一些实时性要求较高的场景，需要进行特殊处理，比如：去主数据库读；\n\n实现的核心Binlog 是 MySQL 中的二进制日志（Binary Log）的简称。它是 MySQL 数据库引擎记录数据库变更操作的一种方式。Binlog 记录了对数据库进行的所有修改，包括 DDL（数据定义语言）操作（如创建、修改和删除表格、索引等）和 DML（数据操作语言）操作（如插入、更新、删除等），以二进制的形式保存在文件中。二进制日志文件的内容是以二进制格式存储的，这些内容对普通用户来说是不可读的。但是，通过使用 mysqlbinlog 工具，可以将二进制日志文件转换成可读的文本格式，以便查看其内容：\n1mysqlbinlog 二进制文件名.序列号 &gt; binlog.txt\n\nBinlog 文件存储的内容大概如此：\n123456789# at 123#210225 12:34:56 server id 1  end_log_pos 234BEGIN# at 234#210225 12:34:56 server id 1  end_log_pos 345INSERT INTO `example_table` VALUES (1, &#x27;example_data&#x27;);# at 345#210225 12:34:56 server id 1  end_log_pos 456COMMIT;\n\n主数据库配置修改 MySQL 配置文件1vim /etc/mysql/my.cnf\n\n\n\n\n\n\n\nTIP\nMysql 5.7.2 以后没有默认配置了，一切配置需要自行配置。\n\n1234server-id=1              # 数据库唯一IDlog-bin=mysql-bin        # mysql-bin日志前缀，可自定义binlog-do-db=db1,db2     # 需要同步的库binlog-ignore-db=db1,db2 # 忽略不同步的库\n\n\n\n\n\n\n\nTIP\nbinlog 两个参数二选一 ，如果都不写，则全部同步。\n\n查询 bin-log 是否开启1show variables like &#x27;%log_bin%&#x27;;\n\n1234567891011+---------------------------------+--------------------------------+| Variable_name                   | Value                          |+---------------------------------+--------------------------------+| log_bin                         | ON                             || log_bin_basename                | /var/lib/mysql/mysql-bin       || log_bin_index                   | /var/lib/mysql/mysql-bin.index || log_bin_trust_function_creators | OFF                            || log_bin_use_v1_row_events       | OFF                            || sql_log_bin                     | ON                             |+---------------------------------+--------------------------------+6 rows in set (0.01 sec)\n\n在主数据库上建立帐户并授权1234567# 以下为 5.x 版本 创建用户并且授权grant replication slave  on *.*  to &#x27;nezha&#x27;@&#x27;%&#x27; identified by &#x27;9527&#x27;;# 以下为 8 版本 创建用户并且授权create user ‘nezha’@‘%’ identified by ‘9527’;grant all privileges on *.* to ‘nezha’@’%’ with grant option; flush privileges;\n\n查看状态1show master status;\n\n1234567# File 和 Position 要记录好+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      155 | dao\t\t     |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)\n\n\n\n\n\n\n\nTIP\n\nFile：当前正在写入的二进制日志文件的名称；\nPosition：当前二进制日志文件中正在写入的位置（以字节为单位），即下一个待写入的位置；\nBinlog_Do_DB：指定要写入二进制日志的数据库，即只记录与这些数据库相关的操作；\nBinlog_Ignore_DB：指定不写入二进制日志的数据库，即忽略与这些数据库相关的操作；\nExecuted_Gtid_Set：已执行的全局事务标识符（GTID）集合，用于复制和恢复；\n\n\n\n从数据库配置修改 MySQL 配置文件1vim /etc/mysql/my.cnf\n\n1234server-id=2         \t    # 数据库唯一IDlog-bin=mysql-bin    \t    # mysql-bin日志前缀replicate-do-db=db1,db2\t\t# 复制指定的数据库replicate-ignore-db=db1,db2 # 忽略指定的数据库\n\n进入数据库命令行执行12345678910111213141516171819stop slave; CHANGE MASTER TO  # 主服务器地址  MASTER_HOST=&#x27;192.168.1.6&#x27;,  # 主服务器账号  MASTER_USER=&#x27;nezha&#x27;,  # 主服务器密码  MASTER_PASSWORD=&#x27;9527&#x27;,  # 主服务器端口  MASTER_PORT=3306,  # 主服务器 binlog 日志文件名,对应的 show master status 的 File  MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,  # 主服务器日志记录起点位置，对应的  show master status 的 Position  MASTER_LOG_POS=155,  # 连接重试次数  MASTER_CONNECT_RETRY=10;start slave;\n\n查看是否配置成功12Slave_IO_Running:Yes Slave_SQL_Running:Yes \n\n\n\n\n\n\n\nTIP\n以上两个都为 yes 则表明成功，IO 表示此进程负责从服务器从主服务器上读取binlog 日志，并写入从服务器上的中继日志，SQL 表示此进程负责读取并且执行中继日志中的binlog日志。\n\nLaravel 实现读写分离做为 PHP 的艺术家框架，Laravel 实现 MySQL 的读写分离非常的简单，只需要更改 database.php 配置文件即可：\n123456789101112131415161718192021222324252627        &#x27;mysql&#x27; =&gt; [            &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;,            &#x27;read&#x27; =&gt; [                &#x27;host&#x27; =&gt; &#x27;192.168.1.6&#x27;,                &#x27;password&#x27; =&gt; env(&#x27;DB_READ_PASSWORD&#x27;, &#x27;&#x27;)            ],            &#x27;write&#x27; =&gt; [                &#x27;host&#x27; =&gt; &#x27;192.168.1.6&#x27;,                &#x27;password&#x27; =&gt; env(&#x27;DB_WRITE_PASSWORD&#x27;, &#x27;&#x27;)            ],            &#x27;url&#x27; =&gt; env(&#x27;DATABASE_URL&#x27;),//            &#x27;host&#x27; =&gt; env(&#x27;DB_HOST&#x27;, &#x27;127.0.0.1&#x27;),            &#x27;port&#x27; =&gt; env(&#x27;DB_PORT&#x27;, &#x27;3306&#x27;),            &#x27;database&#x27; =&gt; env(&#x27;DB_DATABASE&#x27;, &#x27;forge&#x27;),            &#x27;username&#x27; =&gt; env(&#x27;DB_USERNAME&#x27;, &#x27;forge&#x27;),//            &#x27;password&#x27; =&gt; env(&#x27;DB_PASSWORD&#x27;, &#x27;&#x27;),            &#x27;unix_socket&#x27; =&gt; env(&#x27;DB_SOCKET&#x27;, &#x27;&#x27;),            &#x27;charset&#x27; =&gt; &#x27;utf8mb4&#x27;,            &#x27;collation&#x27; =&gt; &#x27;utf8mb4_unicode_ci&#x27;,            &#x27;prefix&#x27; =&gt; &#x27;&#x27;,            &#x27;prefix_indexes&#x27; =&gt; true,            &#x27;strict&#x27; =&gt; true,            &#x27;engine&#x27; =&gt; null,            &#x27;options&#x27; =&gt; extension_loaded(&#x27;pdo_mysql&#x27;) ? array_filter([                PDO::MYSQL_ATTR_SSL_CA =&gt; env(&#x27;MYSQL_ATTR_SSL_CA&#x27;),            ]) : [],        ],\n\n\n\n\n\n\n\nTIP\nLaravel 的 MySQL 驱动是支持：一主多从或多主多从的，实际情况根据项目需求而定。\n\n","slug":"MySQL-读写分离","date":"2024-02-26T12:27:04.000Z","categories_index":"","tags_index":"MySQL","author_index":"哪吒"},{"id":"bed83d6062569a837b3fdb59545fa846","title":"RSA 非对称加密","content":"\n\n\n\n\n\n\n\n\n💡 Tips：RSA 加密是一种非对称加密算法，使用一对密钥进行加解密，分别为公钥和私钥。公钥用于加密信息，私钥用于解密信息。这种设置使得发送者可以使用公钥加密信息并发送给接收者，而只有接收者持有相应私钥才能解密并读取信息。\nRSA 加解密的核心是基于素数（只能被 1 和它自身整除的数）的算法，如果没有一个好的算法，那么加解密效率非常低！工作中移植过 CycloneSSH 的 ssh-keygen 生成公钥私钥效率极低，就是因为没有一个好的素数算法。\n随着现在计算机的计算能力提升和密码分析技术的进步，1024 长度的 rsa 加密已经不安全了，因此在使用时需要谨慎考虑密钥长度和算法的选择。\n非对称与对称加密当我们讨论加密时，通常会涉及两种主要类型：非对称加密和对称加密。\n非对称加密非对称加密使用一对密钥，分别称为公钥和私钥。公钥用于加密数据，而私钥用于解密数据。公钥是公开的，任何人都可以使用它来加密数据。私钥则由数据的接收者保密，用于解密数据。\n\n\n\n\n\n\nTIP\n常见的非对称加密算法是 RSA（Rivest-Shamir-Adleman），非对称加密适用于需要安全通信、数字签名和身份验证等场景。\n\n非对称加密的应用场景\n安全通信：非对称加密常用于安全通信，如电子邮件、文件传输等。发送者使用接收者的公钥来加密数据，而只有接收者拥有相应的私钥才能解密数据；\n数字签名：非对称加密可用于生成和验证数字签名，以确保数据的真实性和完整性。发送者使用自己的私钥来对数据进行签名，而接收者可以使用发送者的公钥来验证签名；\n密钥交换：非对称加密可用于安全地交换对称加密密钥。例如，Diffie-Hellman（SSH协议） 密钥交换协议使用非对称加密算法来协商对称密钥，从而实现安全通信；\n身份验证：非对称加密可用于用户身份验证。例如，用户可以使用其私钥来生成数字签名，以证明其身份。；\n\n对称加密对称加密使用相同的密钥（也称为“秘密密钥”）来加密和解密数据。这意味着发送者和接收者必须事先共享相同的密钥。在加密时，发送者使用密钥将明文转换为密文。然后，接收者使用相同的密钥将密文解密为明文。\n\n\n\n\n\n\nTIP\n常见的对称加密算法包括 AES（高级加密标准）和 DES（数据加密标准）等。对称加密适用于需要高效加密大量数据的场景。\n\n对称加密应用场景\n数据传输加密：对称加密常用于保护数据在传输过程中的安全性。例如，HTTPS 协议就使用对称加密算法来加密数据传输过程中的通信内容；\n数据存储加密：对称加密可以用于保护数据在存储介质上的安全性。例如，加密文件系统（如 BitLocker）使用对称加密算法来加密存储在硬盘上的数据；\n会话加密：对称加密可用于保护网络会话的安全性。例如，常见的 TLS&#x2F;SSL 协议使用对称加密算法来加密客户端和服务器之间的通信会话；\n密码学应用：对称加密可用于密码学应用，如消息认证码（MAC）的生成和验证，以确保数据的完整性和真实性；\n\n生成秘钥对12345678# 第一步：生成私钥，这里我们指定私钥的长度为1024, 长度越长，加解密消耗的时间越长openssl genrsa -out rsa_private_key.pem 1024# 第二步：根据私钥生成对应的公钥openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pub# 第三步：私钥转化成pkcs8格式，【这一步非必须，只是程序解析起来方便】openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out rsa_private_key_pkcs8.pem\n\n\n\n\n\n\n\nTIP\n\nLinux 需安装 OpenSSH：sudo apt-get install openssh-server；\nWindows 10 以及以上的版本自带 SSH 客户端，其他版本可以第三方工具使用 SSH 客户端；\n\n\n\nPHP RSA 加解密123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?phpnamespace App\\Services;class SignService&#123;    protected $publicKey;    protected $privateKey;    /**     * 初始化     * */    public function __construct()    &#123;        $this-&gt;publicKey  = openssl_get_publickey(file_get_contents(&#x27;../rsa_public_key.pub&#x27;));        $this-&gt;privateKey = openssl_get_privatekey(file_get_contents(&#x27;../rsa_private_key_pkcs8.pem&#x27;));    &#125;    /**     * 公钥加密     * @param mixed $data     *     * @return string     */    function encrypt($data)    &#123;        $encrypt = &#x27;&#x27;;        foreach (str_split($data, 117) as $item)        &#123;            $temp = &#x27;&#x27;;            openssl_public_encrypt($item, $encrypt, $this-&gt;publicKey);            $encrypt .= $temp;        &#125;        openssl_free_key($this-&gt;publicKey);        return base64_encode($encrypt);    &#125;    /**     * 私钥解密     * @param mixed $data     *     * @return string     */    function decrypt($data)    &#123;        $data    = base64_decode($data);        $decrypt = &#x27;&#x27;;        foreach (str_split($data, 128) as $item)        &#123;            $temp = &#x27;&#x27;;            openssl_private_decrypt($item, $temp, $this-&gt;privateKey);            $decrypt .= $temp;        &#125;        openssl_free_key($this-&gt;privateKey);        return $decrypt;    &#125;    /**     * 私钥生成签名     * @param mixed $data     *     * @return string     */    function sign($data)    &#123;        $signature = config(&#x27;app.signature&#x27;);        openssl_sign($data, $signature, $this-&gt;privateKey);        openssl_free_key($this-&gt;privateKey);        return base64_encode($signature);    &#125;    /**     * 公钥验证     * @param mixed $data     * @param mixed $sign     *     * @return bool     */    function veritySign($data,$sign)    &#123;        $result = openssl_verify($data, base64_decode($sign), $this-&gt;publicKey);        openssl_free_key($this-&gt;publicKey);        return (bool)$result;    &#125;&#125;\n\n\n\n\n\n\n\nTIP\nPHP 要操作 RSA 需要用到 OpenSSL 扩展库，另外需要注意：RSA 加密采用了分块进行加密，因此有长度限制。对于较长的原文，需要进行分段加解密，分别对每个分段进行加密（117）或解密（128），然后再合并结果。这种方式可以克服 RSA 加密长度的限制，但会出现效率问题，因为分段加解密可能会导致额外的计算开销。\n\n移植 ssh-keygen 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244// libc 依赖#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;// cyclone 依赖#include &quot;path.h&quot;#include &quot;pkc/rsa.h&quot;#include &quot;rng/trng.h&quot;#include &quot;rng/yarrow.h&quot;#include &quot;ssh/ssh_key_export.h&quot;// 随机数种子#define SEED_SIZE 32// rsa 支持的长度#define MIN_SUPPORT_BYTES 2048#define MAX_SUPPORT_BYTES 16384// 默认 ssh 存放路径#define SSH_PATH &quot;/ssh&quot;// 板子上终端最多只能输入 120 左右个字符#define MAX_KEY_LEN 255// Yarrow PRNG 上下文YarrowContext yarrowContext;/** * @brief 符号表 */const char *symbolArray[] = &#123;&quot;.&quot;, &quot;./&quot;, &quot;..&quot;, &quot;../&quot;, &quot;/&quot;&#125;;/** * @brief 状态 */enum state &#123;    HELP,    FAILED_BIT_SIZE,    FAILED_BIT_TYPE&#125;;/** * @brief 生成参数 */struct GenerateParam &#123;    size_t bitSize;    char_t *filename;    char_t *algorithm;&#125; generateParam;/** * @brief 打印信息 * * @param[in] code  状态码 */static void printUsage(int_t code) &#123;    switch (code) &#123;        case HELP:            printf(&quot;usage: ssh-keygen [OPTIONS] &lt;file&gt;...\\n\\n&quot;);            printf(&quot;OPTIONS: [-b bits] [-f output_keyfile] [-t dsa | ecdsa | ed25519 | rsa]\\n\\n&quot;);            printf(&quot;-b &lt;bits&gt; Specify the key length \\n&quot;);            printf(&quot;-f &lt;output_keyfile&gt; Specifies the file name to save the key \\n&quot;);            printf(&quot;-t Specifies the type of key to create \\&quot;Only RSA is supported\\&quot; \\n&quot;);            break;        case FAILED_BIT_SIZE:            printf(&quot;The key length is 2048 range 16384 \\n&quot;);            break;        case FAILED_BIT_TYPE:            printf(&quot;Bits value invalid \\n&quot;);            break;    &#125;    exit(code);&#125;/** * @brief 写入生成的证书秘钥 * * @param[in] certPublicKey  公钥 * @param[in] certPrivateKey 私钥 */static void writeGenerateCertKeys(const char_t *certPublicKey, const char_t *certPrivateKey) &#123;    FILE *pubFile, *priFile;    char_t pubKeyPath[MAX_KEY_LEN];    char_t priKeyPath[MAX_KEY_LEN];    if (generateParam.algorithm == NULL) &#123;        generateParam.algorithm = &quot;rsa&quot;;    &#125;    if (generateParam.filename == NULL) &#123;        if (access(SSH_PATH, F_OK) != 0 &amp;&amp; mkdir(SSH_PATH, 0777) != 0) &#123;            printf(&quot;Saving key \\&quot;%s\\&quot; failed: No such file or directory\\n&quot;, SSH_PATH);            exit(ERROR_DIRECTORY_NOT_FOUND);        &#125;        snprintf(pubKeyPath, MAX_KEY_LEN, &quot;%s%s%s%s&quot;, SSH_PATH, &quot;/id_&quot;, generateParam.algorithm, &quot;.pub&quot;);        snprintf(priKeyPath, MAX_KEY_LEN, &quot;%s%s%s&quot;, SSH_PATH, &quot;/id_&quot;, generateParam.algorithm);    &#125; else &#123;        uint_t isSymbolTableMatched = FALSE;        const char_t *filename = pathGetFilename(generateParam.filename);        for (uint_t i = 0; i &lt; 5; ++i) &#123;            if (osStrcmp(filename, symbolArray[i]) == 0) &#123;                isSymbolTableMatched = TRUE;            &#125;        &#125;        pathRemoveSlash(generateParam.filename);        if (isSymbolTableMatched) &#123;            snprintf(pubKeyPath, MAX_KEY_LEN, &quot;%s%s%s%s&quot;, generateParam.filename, &quot;/id_&quot;, generateParam.algorithm, &quot;.pub&quot;);            snprintf(priKeyPath, MAX_KEY_LEN, &quot;%s%s%s&quot;, generateParam.filename, &quot;/id_&quot;, generateParam.algorithm);        &#125; else &#123;            snprintf(pubKeyPath, MAX_KEY_LEN, &quot;%s%s&quot;, generateParam.filename, &quot;.pub&quot;);            snprintf(priKeyPath, MAX_KEY_LEN, &quot;%s&quot;, generateParam.filename);        &#125;    &#125;    if ((pubFile = fopen(pubKeyPath, &quot;w+&quot;)) == NULL) &#123;        printf(&quot;Saving key \\&quot;%s\\&quot; failed: No such file or directory\\n&quot;, pubKeyPath);        exit(ERROR_FILE_OPENING_FAILED);    &#125;    if ((priFile = fopen(priKeyPath, &quot;w+&quot;)) == NULL) &#123;        fclose(pubFile);        printf(&quot;Saving key \\&quot;%s\\&quot; failed: No such file or directory\\n&quot;, priKeyPath);        exit(ERROR_FILE_OPENING_FAILED);    &#125;    size_t rc1 = fwrite(certPublicKey, sizeof(char_t), osStrlen(certPublicKey), pubFile);    size_t rc2 = fwrite(certPrivateKey, sizeof(char_t), osStrlen(certPrivateKey), priFile);    fclose(pubFile);    fclose(priFile);&#125;/** * @brief rsa 证书生成 * * @return Error Code */static error_t generateRsaCertKeys() &#123;    error_t error;    RsaPublicKey publicKey;    RsaPrivateKey privateKey;    size_t bitSize = generateParam.bitSize ?: MIN_SUPPORT_BYTES;    char_t certPublicKey[bitSize];    char_t certPrivateKey[bitSize];    rsaInitPublicKey(&amp;publicKey);    rsaInitPrivateKey(&amp;privateKey);    if ((error = rsaGenerateKeyPair(YARROW_PRNG_ALGO, &amp;yarrowContext, bitSize, 65537, &amp;privateKey, &amp;publicKey))) &#123;        printf(&quot;Failed RSA key pair generation\\r\\n&quot;);        goto response;    &#125;    if ((error = sshExportRsaPublicKey(&amp;publicKey, certPublicKey, &amp;bitSize, SSH_PUBLIC_KEY_FORMAT_OPENSSH))) &#123;        printf(&quot;Failed Export an RSA public key to PEM format&quot;);        goto response;    &#125;    if ((error = sshExportRsaPrivateKey(&amp;privateKey, &amp;publicKey, certPrivateKey, &amp;bitSize, SSH_PRIVATE_KEY_FORMAT_OPENSSH))) &#123;        printf(&quot;Failed Export an RSA private key to PEM format\\r\\n&quot;);        goto response;    &#125;    writeGenerateCertKeys(certPublicKey, certPrivateKey);    response:    rsaFreePublicKey(&amp;publicKey);    rsaFreePrivateKey(&amp;privateKey);    return error;&#125;/** * @brief ssh-keygen * * @return Unused value */int_t main(int_t argc, char_t *argv[]) &#123;    int_t rc;    error_t error;    uint8_t seed[SEED_SIZE];    if (argc == 2 &amp;&amp; osStrcmp(argv[1], &quot;--help&quot;) == 0) &#123;        printUsage(HELP);    &#125;    /**     * -b 指定密钥长度。对于 RSA 密钥，最低只支持 2048     * -f 指定密钥文件名     * -t 指定要创建的密钥类型。目前仅支持 rsa     */    while ((rc = getopt(argc, argv, &quot;b:f:t:&quot;)) != -1) &#123;        switch (rc) &#123;            case &#x27;b&#x27;:                for (uint_t i = 0; i &lt; osStrlen(optarg); ++i) &#123;                    if (osIsdigit(optarg[i]) == 0) &#123;                        printUsage(FAILED_BIT_TYPE);                    &#125;                &#125;                generateParam.bitSize = atoi(optarg);                if (generateParam.bitSize &lt; MIN_SUPPORT_BYTES || generateParam.bitSize &gt; MAX_SUPPORT_BYTES) &#123;                    printUsage(FAILED_BIT_SIZE);                &#125;                break;            case &#x27;f&#x27;:                generateParam.filename = optarg;                break;            case &#x27;t&#x27;:                if (osStrcmp(optarg, &quot;rsa&quot;) != 0) &#123;                    printUsage(HELP);                &#125;                generateParam.algorithm = optarg;                break;            default:                printUsage(HELP);        &#125;    &#125;    if ((error = yarrowInit(&amp;yarrowContext))) &#123;        printf(&quot;Failed to initialize PRNG!\\r\\n&quot;);        return error;    &#125;    if ((error = yarrowSeed(&amp;yarrowContext, seed, sizeof(seed)))) &#123;        printf(&quot;Failed to seed PRNG!\\r\\n&quot;);        return error;    &#125;    return generateRsaCertKeys();&#125;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423/* *  Multi-precision integer library * *  Copyright The Mbed TLS Contributors *  SPDX-License-Identifier: Apache-2.0 * *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may *  not use this file except in compliance with the License. *  You may obtain a copy of the License at * *  http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. *//* *  The following sources were referenced in the design of this Multi-precision *  Integer library: * *  [1] Handbook of Applied Cryptography - 1997 *      Menezes, van Oorschot and Vanstone * *  [2] Multi-Precision Math *      Tom St Denis *      https://github.com/libtom/libtommath/blob/develop/tommath.pdf * *  [3] GNU Multi-Precision Arithmetic Library *      https://gmplib.org/manual/index.html * *///!!!MODIFIED FILE!!!#include &quot;core/crypto.h&quot;#include &quot;mpi/mpi.h&quot;#include &quot;rng/yarrow.h&quot;extern YarrowContext yarrowContext;#define MBEDTLS_MPI_CHK(f) if((ret = f) != 0) goto cleanup#define mbedtls_mpi Mpi#define mbedtls_mpi_sint int_t#define mbedtls_mpi_uint uint_t#define mbedtls_mpi_init mpiInit#define mbedtls_mpi_free mpiFree#define mbedtls_mpi_sub_int mpiSubInt#define mbedtls_mpi_copy mpiCopy#define mbedtls_mpi_shift_r mpiShiftRight#define mbedtls_mpi_shift_l mpiShiftLeft#define mbedtls_mpi_bitlen mpiGetBitLength#define mbedtls_mpi_cmp_mpi mpiComp#define mbedtls_mpi_cmp_int mpiCompInt#define mbedtls_mpi_add_int mpiAddInt#define mbedtls_mpi_mul_mpi mpiMul#define mbedtls_mpi_mod_mpi mpiMod#define mbedtls_mpi_inv_mod mpiInvMod#define mbedtls_mpi_lset mpiSetValue#define mbedtls_mpi_set_bit mpiSetBitValue#define mbedtls_mpi_exp_mod mpiExpMod#define mbedtls_mpi_sub_abs mpiSubAbs#define mbedtls_mpi_fill_random(xx, nn, algo, ctx) mpiRand(xx, (nn) * 8, algo, ctx)#define ciL    (sizeof(mbedtls_mpi_uint))         /* chars in limb  */#define biL    (ciL &lt;&lt; 3)               /* bits  in limb  */#define biH    (ciL &lt;&lt; 2)               /* half limb size */#define BITS_TO_LIMBS(i)  ( (i) / biL + ( (i) % biL != 0 ) )#define CHARS_TO_LIMBS(i) ( (i) / ciL + ( (i) % ciL != 0 ) )#define MBEDTLS_MPI_MAX_BITS 4096#define MBEDTLS_ERR_MPI_NOT_ACCEPTABLE (2)#define MBEDTLS_ERR_MPI_BAD_INPUT_DATA (3)#define MBEDTLS_ERR_RSA_BAD_INPUT_DATA (4)#define MBEDTLS_ERR_RSA_KEY_GEN_FAILED (5)#define MBEDTLS_ERR_MPI_DIVISION_BY_ZERO (6)#define MBEDTLS_ERR_MPI_NEGATIVE_VALUE (7)static const int small_prime[] =&#123;        3,    5,    7,   11,   13,   17,   19,   23,       29,   31,   37,   41,   43,   47,   53,   59,       61,   67,   71,   73,   79,   83,   89,   97,      101,  103,  107,  109,  113,  127,  131,  137,      139,  149,  151,  157,  163,  167,  173,  179,      181,  191,  193,  197,  199,  211,  223,  227,      229,  233,  239,  241,  251,  257,  263,  269,      271,  277,  281,  283,  293,  307,  311,  313,      317,  331,  337,  347,  349,  353,  359,  367,      373,  379,  383,  389,  397,  401,  409,  419,      421,  431,  433,  439,  443,  449,  457,  461,      463,  467,  479,  487,  491,  499,  503,  509,      521,  523,  541,  547,  557,  563,  569,  571,      577,  587,  593,  599,  601,  607,  613,  617,      619,  631,  641,  643,  647,  653,  659,  661,      673,  677,  683,  691,  701,  709,  719,  727,      733,  739,  743,  751,  757,  761,  769,  773,      787,  797,  809,  811,  821,  823,  827,  829,      839,  853,  857,  859,  863,  877,  881,  883,      887,  907,  911,  919,  929,  937,  941,  947,      953,  967,  971,  977,  983,  991,  997, -103&#125;;/* * Return the number of less significant zero-bits */size_t mbedtls_mpi_lsb( const mbedtls_mpi *X )&#123;    size_t i, j, count = 0;    for( i = 0; i &lt; X-&gt;size; i++ )        for( j = 0; j &lt; 32; j++, count++ )            if( ( ( X-&gt;data[i] &gt;&gt; j ) &amp; 1 ) != 0 )                return( count );    return( 0 );&#125;/* * Modulo: r = A mod b */int mbedtls_mpi_mod_int( mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b )&#123;    size_t i;    mbedtls_mpi_uint x, y, z;    if( b == 0 )        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );    if( b &lt; 0 )        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );    /*     * handle trivial cases     */    if( b == 1 )    &#123;        *r = 0;        return( 0 );    &#125;    if( b == 2 )    &#123;        *r = A-&gt;data[0] &amp; 1;        return( 0 );    &#125;    /*     * general case     */    for( i = A-&gt;size, y = 0; i &gt; 0; i-- )    &#123;        x  = A-&gt;data[i - 1];        y  = ( y &lt;&lt; biH ) | ( x &gt;&gt; biH );        z  = y / b;        y -= z * b;        x &lt;&lt;= biH;        y  = ( y &lt;&lt; biH ) | ( x &gt;&gt; biH );        z  = y / b;        y -= z * b;    &#125;    /*     * If A is negative, then the current y represents a negative value.     * Flipping it to the positive side.     */    if( A-&gt;sign &lt; 0 &amp;&amp; y != 0 )        y = b - y;    *r = y;    return( 0 );&#125;/* * Greatest common divisor: G = gcd(A, B)  (HAC 14.54) */int mbedtls_mpi_gcd( mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B )&#123;    int ret;    size_t lz, lzt;    mbedtls_mpi TG, TA, TB;    mbedtls_mpi_init( &amp;TG ); mbedtls_mpi_init( &amp;TA ); mbedtls_mpi_init( &amp;TB );    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &amp;TA, A ) );    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &amp;TB, B ) );    lz = mbedtls_mpi_lsb( &amp;TA );    lzt = mbedtls_mpi_lsb( &amp;TB );    if( lzt &lt; lz )        lz = lzt;    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;TA, lz ) );    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;TB, lz ) );    TA.sign = TB.sign = 1;    while( mbedtls_mpi_cmp_int( &amp;TA, 0 ) != 0 )    &#123;        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;TA, mbedtls_mpi_lsb( &amp;TA ) ) );        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;TB, mbedtls_mpi_lsb( &amp;TB ) ) );        if( mbedtls_mpi_cmp_mpi( &amp;TA, &amp;TB ) &gt;= 0 )        &#123;            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &amp;TA, &amp;TA, &amp;TB ) );            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;TA, 1 ) );        &#125;        else        &#123;            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &amp;TB, &amp;TB, &amp;TA ) );            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;TB, 1 ) );        &#125;    &#125;    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &amp;TB, lz ) );    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &amp;TB ) );cleanup:    mbedtls_mpi_free( &amp;TG );    mbedtls_mpi_free( &amp;TA );    mbedtls_mpi_free( &amp;TB );    return( ret );&#125;/* * Small divisors test (X must be positive) * * Return values: * 0: no small factor (possible prime, more tests needed) * 1: certain prime * MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: certain non-prime * other negative: error */static int mpi_check_small_factors( const mbedtls_mpi *X )&#123;    int ret = 0;    size_t i;    mbedtls_mpi_uint r;    if( ( X-&gt;data[0] &amp; 1 ) == 0 )        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );    for( i = 0; small_prime[i] &gt; 0; i++ )    &#123;        if( mbedtls_mpi_cmp_int( X, small_prime[i] ) &lt;= 0 )            return( 1 );        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &amp;r, X, small_prime[i] ) );        if( r == 0 )            return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );    &#125;cleanup:    return( ret );&#125;/* * Miller-Rabin pseudo-primality test  (HAC 4.24) */static int mpi_miller_rabin( const mbedtls_mpi *X,                             const PrngAlgo *prngAlgo, void *prngContext)&#123;    int ret, count;    size_t i, j, k, n, s;    mbedtls_mpi W, R, T, A; //, RR;    mbedtls_mpi_init( &amp;W );    mbedtls_mpi_init( &amp;R );    mbedtls_mpi_init( &amp;T );    mbedtls_mpi_init( &amp;A );    //mbedtls_mpi_init( &amp;RR );    /*     * W = |X| - 1     * R = W &gt;&gt; lsb( W )     */    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &amp;W, X, 1 ) );    s = mbedtls_mpi_lsb( &amp;W );    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &amp;R, &amp;W ) );    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;R, s ) );    i = mbedtls_mpi_bitlen( X );    /*     * HAC, table 4.4     */    n = ( ( i &gt;= 1300 ) ?  2 : ( i &gt;=  850 ) ?  3 :          ( i &gt;=  650 ) ?  4 : ( i &gt;=  350 ) ?  8 :          ( i &gt;=  250 ) ? 12 : ( i &gt;=  150 ) ? 18 : 27 );    for( i = 0; i &lt; n; i++ )    &#123;        /*         * pick a random A, 1 &lt; A &lt; |X| - 1         */        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &amp;A, X-&gt;size * ciL, prngAlgo, prngContext ) );        if( mbedtls_mpi_cmp_mpi( &amp;A, &amp;W ) &gt;= 0 )        &#123;            j = mbedtls_mpi_bitlen( &amp;A ) - mbedtls_mpi_bitlen( &amp;W );            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;A, j + 1 ) );        &#125;        A.data[0] |= 3;        count = 0;        do &#123;            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &amp;A, X-&gt;size * ciL, prngAlgo, prngContext ) );            j = mbedtls_mpi_bitlen( &amp;A );            k = mbedtls_mpi_bitlen( &amp;W );            if (j &gt; k) &#123;                MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &amp;A, j - k ) );            &#125;            if (count++ &gt; 30) &#123;                return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;            &#125;        &#125; while ( mbedtls_mpi_cmp_mpi( &amp;A, &amp;W ) &gt;= 0 ||                  mbedtls_mpi_cmp_int( &amp;A, 1 )  &lt;= 0    );        /*         * A = A^R mod |X|         */        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &amp;A, &amp;A, &amp;R, X /*, &amp;RR*/ ) );        if( mbedtls_mpi_cmp_mpi( &amp;A, &amp;W ) == 0 ||            mbedtls_mpi_cmp_int( &amp;A,  1 ) == 0 )            continue;        j = 1;        while( j &lt; s &amp;&amp; mbedtls_mpi_cmp_mpi( &amp;A, &amp;W ) != 0 )        &#123;            /*             * A = A * A mod |X|             */            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &amp;T, &amp;A, &amp;A ) );            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &amp;A, &amp;T, X  ) );            if( mbedtls_mpi_cmp_int( &amp;A, 1 ) == 0 )                break;            j++;        &#125;        /*         * not prime if A != |X| - 1 or A == 1         */        if( mbedtls_mpi_cmp_mpi( &amp;A, &amp;W ) != 0 ||            mbedtls_mpi_cmp_int( &amp;A,  1 ) == 0 )        &#123;            ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;            break;        &#125;    &#125;cleanup:    mbedtls_mpi_free( &amp;W );    mbedtls_mpi_free( &amp;R );    mbedtls_mpi_free( &amp;T );    mbedtls_mpi_free( &amp;A );    //mbedtls_mpi_free( &amp;RR );    return( ret );&#125;/* * Pseudo-primality test: small factors, then Miller-Rabin */int mbedtls_mpi_is_prime( const mbedtls_mpi *X,                  const PrngAlgo *prngAlgo, void *prngContext )&#123;    int ret;    mbedtls_mpi XX;    XX.sign = 1;    XX.size = X-&gt;size;    XX.data = X-&gt;data;    if( mbedtls_mpi_cmp_int( &amp;XX, 0 ) == 0 ||        mbedtls_mpi_cmp_int( &amp;XX, 1 ) == 0 )        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );    if( mbedtls_mpi_cmp_int( &amp;XX, 2 ) == 0 )        return( 0 );    if( ( ret = mpi_check_small_factors( &amp;XX ) ) != 0 )    &#123;        if( ret == 1 )            return( 0 );        return( ret );    &#125;    return( mpi_miller_rabin( &amp;XX, prngAlgo, prngContext ) );&#125;error_t mpiCheckProbablePrime(const Mpi *a)&#123;   int err;      err = mbedtls_mpi_is_prime(a, YARROW_PRNG_ALGO, &amp;yarrowContext);      if(err == 0)      return NO_ERROR;   else if(err == MBEDTLS_ERR_MPI_NOT_ACCEPTABLE)      return ERROR_INVALID_VALUE;   else      return ERROR_FAILURE;&#125;\n\n\n\n\n\n\n\nTIP\n基于标准的 Posix 接口和 CycloneCRYPTO 完成的 ssh-keygen 客户端，可以用于生成 rsa 的秘钥对，CycloneCRYPTO 官方并未提供素数生成的算法，此为开源的一个素数算法实现。\n\n","slug":"RSA-非对称加密","date":"2024-02-26T11:53:22.000Z","categories_index":"","tags_index":"加密算法","author_index":"哪吒"},{"id":"709b09d4ae43a807a27c1aa5f06ca26b","title":"Compoer","content":"\n\n\n\n\n\n\n\n\n💡 Tips：先了解一下历史，从拷贝第三方代码到项目中(1994)，到 PEAR 安装依赖包(1999)，再到 Composer 兴起(2012)，PHP 社区经历了将近 20 年的探索。PHP 这门古老的语言，也在不断的发展更新，在 Web 领域一直发光发热。 Composer 作为目前 PHP 包依赖管理的最佳工具，值得每一位 PHP 开发人员掌握。\n什么是 Composer？是 PHP 用来管理依赖（dependency）关系的工具。可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会自动安装这些依赖的库文件。\nCompoer 用法项目中的 composer.json 文件是 Composer 的核心配置文件，它规定了项目所需的依赖包以及它们的版本信息，从而指导 Composer 安装和管理这些依赖项。该文件中最重要的部分是 require 部分，该部分告诉 Composer 期望安装的包及其版本：\n\n\n安装依赖1composer install\n\n\n\n\n\n\n\nTIP\n在项目根目录下执行，composer install 命令，Composer 会自动分析依赖，安装最合适的包到 vendor 目录下，安装完毕后，vendor 目录下会生成 autoload.php 文件。在项目的入口文件中包含此文件：require DIR . “&#x2F;vendor&#x2F;autoload.php”;，接下来便可在项目的任何地方引用依赖包中的接口和类。\n\n常用命令\n\n\n命令\n描述\n\n\n\ncomposer search\n根据关键字查找依赖包\n\n\ncomposer request\n引入依赖，声明项目或者全局( global，用户名全局，非系统全局)依赖某个包\n\n\ncomposer install\n安装 composer.json 声明的依赖包，最终安装的依赖包版本可能取决于有无 composer.lock 文件\n\n\ncomposer update\n更新依赖到最新版本，相当于删除 composer.lock 文件后执行 composer install\n\n\ncomposer info\n查看安装的依赖包信息，与 composer show 等价\n\n\ncomposer dumpautoload\n加 -o 选项可导出优化的加载器\n\n\ncomposer why(-not)\n查看（不）安装某个包的原因\n\n\nComposer 加速Compoer 安装依赖比较慢，问题是资源都是在外国服务器上，Compoer 2.x 除了网络问题，它已经很快了，不需要在使用其它插件辅助了。切换国内源，所有的项目都会使用该镜像地址：\n1composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n\nComposer 加载机制Composer 是 PHP 中最受欢迎的依赖管理工具之一，它通过自动加载机制有效地管理项目的依赖关系。了解 Composer 的加载机制对于理解 PHP 项目的自动加载过程至关重要。\n1. composer.json 文件\n依赖声明： composer.json 文件是 Composer 的核心配置文件，其中声明了项目所需的依赖包及其版本要求；\n自动加载配置： composer.json 中的 autoload 字段定义了自动加载规则，告诉 Composer 如何加载项目中的类文件；\n\n2. 自动加载规则Composer 的自动加载规则基于 PSR-4 和 PSR-0 标准：\n\nPSR-4 规范： PSR-4 规定了类命名空间与目录结构之间的映射关系；\nPSR-0 规范： PSR-0 是早期的自动加载规范，已被 PSR-4 取代，但一些旧版的库仍然使用；\n\n3. Composer Autoload 指令Composer Autoload 指令是项目中的 autoload.php 文件，由 Composer 自动生成并负责自动加载类文件：\n\n引入 Autoload 文件： 项目的入口文件通常会引入 Composer 自动生成的 autoload.php 文件；\nAutoload 机制： autoload.php 文件通过注册自动加载函数（spl_autoload_register）来实现类的自动加载；\n\n4. 类的加载流程\n自动加载注册： 项目启动时，autoload.php 文件会注册自动加载函数，用于加载项目中的类文件；\n命名空间解析： 当代码中使用了未加载的类时，PHP 解释器会触发自动加载函数；\n自动加载函数： 自动加载函数根据类的命名空间和自动加载规则，找到对应的类文件并加载；\n\n5. 缓存机制Composer 提供了类加载的缓存机制，可以加速加载过程：\n\nClassmap： Composer 可以生成一个类映射表，加速类文件的查找过程；\nOptimize-autoloader： Composer 提供了 optimize-autoloader 指令（composer dumpautoload -o），用于生成和更新类加载的缓存文件；\n\n实现自动加载123456789101112131415161718&lt;?php// 定义项目根目录常量define(&#x27;ROOT_PATH&#x27;, __DIR__);// 自动加载函数spl_autoload_register(function ($className) &#123;    // 将类名转换为文件路径    $classFile = ROOT_PATH . &#x27;/&#x27; . str_replace(&#x27;\\\\&#x27;, &#x27;/&#x27;, $className) . &#x27;.php&#x27;;        // 检查类文件是否存在    if (file_exists($classFile)) &#123;        // 加载类文件        require_once $classFile;    &#125;&#125;);// 可选的其他初始化逻辑...\n\n\n\n\n\n\n\nTIP\nspl_autoload_register 函数用于注册自定义的自动加载函数，当 PHP 遇到未定义的类时，会触发这些自动加载函数来尝试加载对应的类文件。具体来说，spl_autoload_register 函数的调用会触发两种情况下的自动加载：\n\n使用未定义的类： 当代码中使用了一个未定义的类时，PHP 解释器会检测当前是否已经注册了自动加载函数。如果已经注册，则会按照注册的顺序依次调用这些自动加载函数，尝试加载这个未定义的类；\n手动调用 spl_autoload 函数： 如果需要手动触发自动加载，可以调用 spl_autoload 函数，并传入未定义的类名作为参数。这样 PHP 会立即尝试调用已注册的自动加载函数来加载这个类；\n\n\n\n","slug":"Compoer","date":"2024-02-22T10:58:00.000Z","categories_index":"","tags_index":"PHP","author_index":"哪吒"},{"id":"a48e6dda0c21e40880cba7e763278b04","title":"Docker","content":"\n\n\n\n\n\n\n\n\n💡 Tips：Docker 是一个开源的容器化平台，用于轻松打包、发布和运行应用程序。通过 Docker，开发者可以将应用程序及其依赖项打包到一个称为镜像的标准化单元中，然后在任何支持 Docker 的环境中部署这些镜像为容器。Docker 的核心原理是利用操作系统级虚拟化技术，如 Linux 容器 (LXC)，来创建轻量级、隔离的执行环境。这使得开发人员能够实现快速、一致和可靠的应用程序交付，并实现更高效的资源利用。\n三大核心\n镜像（Image）：镜像是一个轻量级、独立、可执行的软件包，它包含了运行应用程序所需的所有内容，包括代码、运行时、库、环境变量和配置文件等。Docker 镜像是通过文件系统的层叠方式构建而成的，每一层都是只读的，它们共同组成了最终的镜像；\n容器（Container）：容器是 Docker 镜像的运行实例。容器利用镜像提供的文件系统、代码和运行时环境，独立运行在宿主机上。每个容器都是相互隔离的，拥有自己的文件系统、网络和进程空间，但它们共享主机操作系统的内核；\n仓库（Repository）：仓库是用来存放 Docker 镜像的地方。它可以被看作是一个集中的存储库，用于管理和分享镜像。仓库分为两种类型：公有仓库和私有仓库。Docker Hub 是最常见的公有仓库，而私有仓库则可以搭建在本地或者在云服务上，用于组织内部或个人使用；\n\n常用命令\n\n\n命令\n解释\n\n\n\nsystemctl start docker\n启动 docker\n\n\nsystemctl restart docker\n重启 docker\n\n\ndocker images\n查看所有镜像\n\n\ndocker pull 镜像\n在 dockerhub 当中拉取镜像\n\n\ndocker rmi 镜像\n删除镜像\n\n\ndocker ps\n查看所有运行容器\n\n\ndocker ps -a\n查看所有容器\n\n\ndocker exec -it 容器 bash\n进入容器\n\n\ndocker rm 容器\n删除容器，要先关闭容器才能删\n\n\ndocker stop 容器\n停止容器\n\n\ndocker start 容器\n启动容器\n\n\ndocker restart 容器\n重启容器\n\n\ndocker cp 宿主机目录 容器名称:&#x2F;容器里文件\n复制宿主机文件，到容器\n\n\ndocker cp 容器名称:&#x2F;容器文件 宿主机目录\n复制容器文件，到宿主机\n\n\ndocker -v 本地文件:&#x2F;容器文件\n映射文件，宿主机容器文件同步\n\n\ndocker logs 容器\n查看容器日志\n\n\n安装ubuntu12345678910111213141516171819201、若安装过先删除，若无忽略sudo apt-get remove docker docker-engine docker.io2、安装扩展sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common3、信任 GPGcurl -fsSL https://mirrors.huaweicloud.com/docker-ce/linux/debian/gpg | sudo apt-key add -4、添加仓库sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.huaweicloud.com/docker-ce/linux/debian $(lsb_release -cs) stable&quot;5、安装apt install docker-ce6、以上还没安装好，那肯定要这样了wget https://mirrors.huaweicloud.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmapt install containerd.io-1.2.6-3.3.el7.x86_64.rpmapt install docker-ce\n\ncentos1234567891011121314151617181920211、若安装过先删除，若无忽略sudo yum remove docker docker-common docker-selinux docker-engine2、安装扩展sudo yum install -y yum-utils device-mapper-persistent-data lvm23、下载 repo 文件wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.huaweicloud.com/docker-ce/linux/centos/docker-ce.repo4、软件仓库地址替换为：sudo sed -i &#x27;s+download.docker.com+mirrors.huaweicloud.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo5、更新索引文件并安装sudo yum makecache fastsudo yum install docker-ce6、以上还没安装好，那肯定要这样了wget https://mirrors.huaweicloud.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install docker-ce\n\n切换国内源1234567891011121、编辑配置文件vim /etc/docker/daemon.json2、添加中科大源&#123;  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]&#125;# 如果 etc/docker 下不存在 daemon.json，新建一个即可3、重启 dockersystemctl restart docker\n\n容器互联早期容器之间的互联都是使用 –link 连接，现在不在推荐使用。随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 –link 参数。\n查看网络1docker network ls\n\n\n\n\n网络类型\n描述\n特点\n\n\n\nbridge\n所有 Docker 安装中都存在的默认网络，表示为 docker0 网络。除非使用 docker run --net=选项另行指定，否则 Docker 守护进程默认会将容器连接到此网络。在主机上使用 ifconfig命令可以看到此网桥是主机的网络堆栈的一部分。\n- 提供了隔离性，每个容器拥有自己的网络命名空间。\n\n\n\n容器之间可以相互通信，但默认情况下与主机之间是相互隔离的。\nDocker 容器之间可以使用容器名称进行通信。 || none | 在容器上添加了一个特定于容器的网络堆栈，该容器缺少网络接口。 | - 容器没有网络接口，因此无法与外部通信，除非手动配置网络。\n适用于一些特殊场景，例如需要完全隔离的容器或测试场景。 || host | 在主机网络堆栈上添加一个容器，容器中的网络配置与主机相同。 | - 容器与主机共享网络命名空间，因此容器可以直接访问主机的网络接口和端口。\n容器无需进行网络地址转换（NAT），因此网络性能较高。\n容器之间无法相互访问，除非在主机上进行端口映射。 |\n\n创建网络1docker network create -d bridge 网络名称\n\nPHP 开发套件PHP拉取镜像1docker pull php:fpm\n\n创建容器1docker run --name php -p 9000:9000 --network name -v /宿主机存放代码的目录:/var/www/html -it -d php:fpm\n\n\n\n\n命令\n命令详解\n\n\n\nrun\n创建一个容器\n\n\n–name\n指定容器名称，为空 docker 自动分配名称\n\n\n-p\n端口映射，将容器的 9000 端口映射到主机的 9000 端口\n\n\n–network\n选择网络\n\n\n-v\n映射文件，宿主机容器文件同步\n\n\n-it\n表示让容器的标准输入打开,并且分配一个伪终端\n\n\n-d\n后台运行容器\n\n\n基本配置12345678910111213141516171819202122232425262728# 进入容器docker exec -it php bash# 中科大源,然后下载需要的软件sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.listapt update# Composer 安装1、curl -sS https://getcomposer.org/installer | php2、mv composer.phar /usr/local/bin/composer3、composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/# 修改 /usr/local/etc/php-fpm.conf include 路径include=/usr/local/etc/php-fpm.d/*.conf# 开启扩展命令/usr/local/bin/docker-php-ext-install mysqli# 常见的一些扩展可以这样安装了，没有的就得自己下载安装了。下载扩展到 /usr/src/php/ext 目录当中,注意：如果没有 /usr/src/php/ext 别慌执行一下 /usr/local/bin/docker-php-ext-install 一个没有的扩展，然后文件夹就会有了，每次安装好扩展之后 php 自动删除！# 关闭扩展命令docker-php-ext-enable mysqli# php.ini这个镜像给我们打包的配置文件，分开发和生产二个配置文件，在 /usr/local/etc/php 当中# 重启容器docker restart php\n\nMySQL如果是真实线上的项目，不推荐安装在容器当中，应当使用网络版本的 MySQL 本地开发无关紧要。\n拉取镜像1docker pull mysql\n\n创建容器1docker run -p 3306:3306 --name mysql --network name -v /xxx:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d --privileged=true mysql\n\n\n\n\n命令\n命令详解\n\n\n\nrun\n创建一个容器\n\n\n–name\n指定容器名称，为空 docker 自动分配名称\n\n\n-v\n映射文件，宿主机容器文件同步\n\n\n-p\n端口映射，将容器的 3306 端口映射到主机的 3306 端口\n\n\n-e\n设置环境变量，初始化 Mysql 密码\n\n\n-d\n后台运行容器\n\n\n–privileged&#x3D;true\n可能会碰到权限问题，需要加参数\n\n\n基本配置12345678910111213141516171819202122# 进入容器docker exec -it mysql bash # 更换软件源，中科大源sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.listapt update# 修改密码认证 mysql 8 加密方式改变了mysql&gt;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;root&#x27;;mysql&gt;flush privileges;# 如果需要创建一个帐号，并且赋予权限，不需要忽略mysql&gt;create user &#x27;用户名&#x27;@&#x27;访问主机&#x27; identified by &#x27;密码&#x27;;mysql&gt;grant 权限 on *.* to &#x27;帐号&#x27;@&#x27;%&#x27; WITH GRANT OPTION;# 修改 /etc/mysql/conf.d 下面的 mysql.cnf 添加以下配置，没有就创建 mysql.cnf[mysqld]port=3306default_authentication_plugin=mysql_native_password# 重启容器docker restart mysql\n\nNginx拉取镜像1docker pull nginx\n\n创建容器1docker run --name nginx -p 80:80 --network name -v /宿主机存放代码的目录:/usr/share/nginx/html -d nginx\n\n\n\n\n命令\n命令详解\n\n\n\nrun\n创建一个容器\n\n\n–name\n指定容器名称，为空 docker 自动分配名称\n\n\n-p\n端口映射，将容器的 80 端口映射到主机的 80 端口\n\n\n–network\n选择网络\n\n\n-v\n映射文件，宿主机容器文件同步\n\n\n-d\n后台运行容器\n\n\n基本配置1234567891011121314151617181920212223242526272829303132333435363738394041# 中科大源,然后下载需要的软件sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.listapt update# 贴上我的配置，Nginx 配置文件所在目录 /etc/nginxserver &#123;    # 监听端口    listen       80;    # 域名    server_name  dev.test;    # 程序目录    root   /usr/share/nginx/html/dao/public;    # 默认访问    index  index.php;    # 字符集编码    charset utf-8;    # 错误日志    access_log  /var/log/nginx/app.access.log  main;    # 默认请求 正则匹配    location / &#123;        try_files $uri $uri/ /index.php?$query_string;    &#125;    # 正则匹配到 PHP 文件请求 ，扔给 FastCGI     location ~ \\.php$ &#123;        root           /var/www/html/dao/public;        fastcgi_pass   php-fpm:9000;        fastcgi_index  index.php;        include        fastcgi_params;        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;    &#125;&#125;# 重启 nginxdocker restart nginx\n\nRedis如果是真实线上的项目，不推荐安装在容器当中，应当使用网络版本的 redis 本地开发无关紧要。\n拉取镜像1docker pull redis\n\n创建容器1docker run --name redis -p 6379:6379 --network name -d redis redis-server --appendonly yes --requirepass &quot;mypassword&quot;\n\nMemcached如果是真实线上的项目，不推荐安装在容器当中，应当使用网络版本的 memcached 本地开发无关紧要。\n拉取镜像1docker pull memcached\n\n创建容器1docker run --name memcached -p 11211:11211 -m 64m -d memcached\n\nDockerfileDockerfile 是一个文本文件，包含了一系列用于构建 Docker 镜像的指令和配置。通过 Dockerfile，开发者可以定义镜像中的环境、依赖项、运行时配置等内容，以及如何构建和配置容器。简单点来说就是创建自定义镜像，Dockerfile 一般搭配着项目的 CI&#x2F;CD 一起出现。\n常用命令\n\n\n命令\n说明\n\n\n\nFROM\n指定基础镜像\n\n\nMAINTAINER\n指定镜像维护者的信息\n\n\nRUN\n在镜像中执行命令\n\n\nCMD\n容器启动后默认执行的命令\n\n\nENTRYPOINT\n容器启动时执行的命令\n\n\nCOPY\n将文件复制到镜像中\n\n\nADD\n类似于 COPY，但功能更强大，可以自动解压缩文件和 URL\n\n\nWORKDIR\n设置工作目录\n\n\nENV\n设置环境变量\n\n\nEXPOSE\n声明容器运行时需要暴露的端口\n\n\nVOLUME\n创建一个挂载点，用于持久化数据\n\n\nUSER\n指定容器运行时的用户名或 UID\n\n\nARG\n定义构建时的参数\n\n\nONBUILD\n定义触发器指令，会在后续构建过程中被触发执行\n\n\nQt 成品 Dockerfilex86 交叉 FTD2000（ARM64）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374FROM ubuntu:16.04ENV DEBIAN_FRONTEND noninteractiveRUN sed -i &#x27;1 i deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;2 i deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;3 i deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;4 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;5 i deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;6 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;7 i deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;8 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&#x27; /etc/apt/sources.listRUN apt update &amp;&amp; apt install -y build-essential wget curl cmake python gperf bison flex pkg-configWORKDIR /optRUN apt install -y xz-utils &amp;&amp; wget -q 工具链：gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz &amp;&amp; \\    xz -d gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz &amp;&amp; \\    tar -xf gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar &amp;&amp; \\    mv gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu ./aarch64-linux-gnu &amp;&amp; \\    rm -rf gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tarENV PATH=$PATH:/opt/aarch64-linux-gnu/binRUN wget -q 地址：llvm-7.0.1.tar.gz &amp;&amp; \\    tar -xf llvm-7.0.1.tar.gz &amp;&amp; \\    rm -rf llvm-7.0.1.tar.gzRUN wget -q https://download.qt.io/archive/qt/5.12/5.12.12/single/qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    xz -d qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    tar -xf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    rm -rf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    cd qt-everywhere-src-5.12.12 &amp;&amp; \\    mkdir buildWORKDIR /sysrootRUN wget -q 打包好的 sysroot：/FTD2000.tar.gz &amp;&amp; \\    tar -zxf FTD2000.tar.gz &amp;&amp; \\    rm -rf FTD2000.tar.gzRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    sed -e &#x27;1163 s|^|//|&#x27; -i /opt/llvm-7.0.1/llvm/projects/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cc &amp;&amp; \\    cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/x86-llvm -DLLVM_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install &amp;&amp; cp /opt/llvm-7.0.1/llvm/build/bin/clang-tblgen /opt/x86-llvm/binRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ cmake -G &quot;Unix Makefiles&quot; --enable-targets=aarch64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/arm-llvm -DLLVM_TABLEGEN=/opt/x86-llvm/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/x86-llvm/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF -DCMAKE_SYSROOT=/sysroot .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install     RUN cp /sysroot/usr/lib/libstdc++.so.6.0.22 /opt/arm-llvm/lib &amp;&amp; cd /opt/arm-llvm/lib &amp;&amp; ln -s libstdc++.so.6.0.22 libstdc++.so.6 RUN cd /opt &amp;&amp; tar -zcf llvm.tar.gz arm-llvm &amp;&amp; rm -rf /opt/arm-llvm/bin &amp;&amp; cp -r /opt/x86-llvm/bin /opt/arm-llvm &amp;&amp; rm -rf /opt/llvm-7.0.1ENV LLVM_INSTALL_DIR=/opt/x86-llvmRUN cd /opt/qt-everywhere-src-5.12.12/build &amp;&amp; /opt/qt-everywhere-src-5.12.12/configure -prefix /qt5.12.12 \\    -opensource \\    -confirm-license \\    -release \\    -xplatform linux-aarch64-gnu-g++ \\    -make libs \\    -make tools \\    -nomake tests \\    -nomake examples \\    -qt-zlib \\    -sysroot /sysroot &amp;&amp; make -j64 &amp;&amp; make -j64 installRUN rm -rf /opt/qt-everywhere-src-5.12.12ENV LLVM_INSTALL_DIR=/opt/arm-llvmENV QTC_ENABLE_CLANG_LIBTOOLING=trueENV PATH=$PATH:/sysroot/qt5.12.12/bin\n\nx86 交叉 龙芯3A4000（mips64）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869FROM ubuntu:18.04ENV DEBIAN_FRONTEND noninteractiveRUN apt update &amp;&amp; apt install -y build-essential wget curl cmake python gperf bison flex pkg-config gcc-8-mips64el-linux-gnuabi64 g++-8-mips64el-linux-gnuabi64RUN rm -rf /usr/mips64el-linux-gnuabi64/lib &amp;&amp; rm -rf /usr/mips64el-linux-gnuabi64/lib64WORKDIR /optRUN wget -q 地址：llvm-7.0.1.tar.gz &amp;&amp; \\    tar -xf llvm-7.0.1.tar.gz &amp;&amp; \\    rm -rf llvm-7.0.1.tar.gzRUN wget -q https://download.qt.io/archive/qt/5.12/5.12.12/single/qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    xz -d qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    tar -xf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    rm -rf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    cd qt-everywhere-src-5.12.12 &amp;&amp; mkdir build    WORKDIR /sysrootRUN wget -q 打包好的 sysroot：jari-works-3a4000-system-usr.tar &amp;&amp; \\    tar -xf jari-works-3a4000-system-usr.tar &amp;&amp; \\    rm -rf jari-works-3a4000-system-usr.tarRUN wget -q 打包好的 sysroot：jari-works-3a4000-system-lib.tar.tar.gz &amp;&amp; \\    tar -zxf jari-works-3a4000-system-lib.tar.tar.gz &amp;&amp; \\    rm -rf jari-works-3a4000-system-lib.tar.tar.gzRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/x86-llvm -DLLVM_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install &amp;&amp; cp /opt/llvm-7.0.1/llvm/build/bin/clang-tblgen /opt/x86-llvm/binRUN rm -rf /sysroot/usr/bin &amp;&amp; cd /opt/llvm-7.0.1/llvm &amp;&amp; rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    CC=mips64el-linux-gnuabi64-gcc-8 CXX=mips64el-linux-gnuabi64-g++-8 cmake -G &quot;Unix Makefiles&quot; --enable-targets=mips -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/mips-llvm -DLLVM_TABLEGEN=/opt/x86-llvm/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/x86-llvm/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF -DCMAKE_SYSROOT=/sysroot .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install    RUN cd /opt &amp;&amp; tar -zcf llvm.tar.gz mips-llvm &amp;&amp; rm -rf /opt/mips-llvm/bin &amp;&amp; cp -r /opt/x86-llvm/bin /opt/mips-llvm &amp;&amp; rm -rf /opt/llvm-7.0.1ENV LLVM_INSTALL_DIR=/opt/x86-llvmRUN cd /opt/qt-everywhere-src-5.12.12/build &amp;&amp; cp -r /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-aarch64-gnu-g++ /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-mips64el-gnu-g++ &amp;&amp; \\    sed -i &#x27;14c QMAKE_CC          = mips64el-linux-gnuabi64-gcc-8&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;15c QMAKE_CXX         = mips64el-linux-gnuabi64-g++-8&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;16c QMAKE_LINK        = mips64el-linux-gnuabi64-g++-8&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;17c QMAKE_LINK_SHLIB  = mips64el-linux-gnuabi64-g++-8&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;20c QMAKE_AR          = mips64el-linux-gnuabi64-ar cqs&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;21c QMAKE_OBJCOPY     = mips64el-linux-gnuabi64-objcopy&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;22c QMAKE_NM          = mips64el-linux-gnuabi64-nm -P&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;23c QMAKE_STRIP       = mips64el-linux-gnuabi64-strip&#x27; ../qtbase/mkspecs/linux-mips64el-gnu-g++/qmake.conf &amp;&amp; \\    /opt/qt-everywhere-src-5.12.12/configure -prefix /qt5.12.12 \\    -opensource \\    -confirm-license \\    -release \\    -xplatform linux-mips64el-gnu-g++ \\    -make libs \\    -make tools \\    -nomake tests \\    -nomake examples \\    -qt-zlib \\    -sysroot /sysroot &amp;&amp; \\    make -j64 &amp;&amp; make -j32 installRUN rm -rf /opt/qt-everywhere-src-5.12.12ENV LLVM_INSTALL_DIR=/opt/mips-llvmENV QTC_ENABLE_CLANG_LIBTOOLING=trueENV PATH=$PATH:/sysroot/qt5.12.12/bin\n\nx86 交叉 龙芯3A5000（LoongArch64）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485FROM ubuntu:18.04ENV DEBIAN_FRONTEND noninteractiveRUN sed -i &#x27;1 i deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;2 i deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;3 i deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;4 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;5 i deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;6 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;7 i deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&#x27; /etc/apt/sources.list &amp;&amp; \\    sed -i &#x27;8 i deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse&#x27; /etc/apt/sources.listRUN apt update &amp;&amp; apt install -y build-essential wget curl cmake python gperf bison flex pkg-configWORKDIR /optRUN wget -q 地址：llvm-7.0.1.tar.gz &amp;&amp; \\    tar -xf llvm-7.0.1.tar.gz &amp;&amp; \\    rm -rf llvm-7.0.1.tar.gzRUN wget http://ftp.loongnix.cn/toolchain/gcc/release/loongarch/gcc8/toolchain-loongarch64-linux-gnu-cross-830-rc1.0-2022-04-22.tar.xz &amp;&amp; \\    tar -xf toolchain-loongarch64-linux-gnu-cross-830-rc1.0-2022-04-22.tar.xz &amp;&amp; \\    rm -rf toolchain-loongarch64-linux-gnu-cross-830-rc1.0-2022-04-22.tar.xz &amp;&amp; \\    mv toolchain-loongarch64-linux-gnu-cross-830-rc1.0-2022-04-22 loongaarchENV PATH=$PATH:/opt/loongaarch/binRUN wget https://download.qt.io/archive/qt/5.12/5.12.12/single/qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    xz -d qt-everywhere-src-5.12.12.tar.xz &amp;&amp; \\    tar -xf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    rm -rf qt-everywhere-src-5.12.12.tar &amp;&amp; \\    sed -i &#x27;493c u.asBits.payload = reinterpret_cast&lt;int64_t&gt;(ptr);&#x27; /opt/qt-everywhere-src-5.12.12/qtscript/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.h &amp;&amp; \\    sed -i &#x27;505c u.asBits.payload = reinterpret_cast&lt;int64_t&gt;(const_cast&lt;JSCell*&gt;(ptr));&#x27; /opt/qt-everywhere-src-5.12.12/qtscript/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.h &amp;&amp; \\    cd qt-everywhere-src-5.12.12 &amp;&amp; mkdir buildWORKDIR /sysrootRUN wget 打包好的 sysroot：loongson-3A5000.tar.gz &amp;&amp; \\    tar -zxf loongson-3A5000.tar.gz &amp;&amp; \\    rm -rf loongson-3A5000.tar.gzRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    sed -e &#x27;1163 s|^|//|&#x27; -i /opt/llvm-7.0.1/llvm/projects/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cc &amp;&amp; \\    cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/x86-llvm -DLLVM_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/llvm-7.0.1/llvm/build/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install &amp;&amp; cp /opt/llvm-7.0.1/llvm/build/bin/clang-tblgen /opt/x86-llvm/binRUN cd /opt/llvm-7.0.1/llvm &amp;&amp; rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; \\    CC=loongarch64-linux-gnu-gcc CXX=loongarch64-linux-gnu-g++ cmake -G &quot;Unix Makefiles&quot; --enable-targets=loongaarch64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/loongaarch64-llvm -DLLVM_TABLEGEN=/opt/x86-llvm/bin/llvm-tblgen -DCLANG_TABLEGEN=/opt/x86-llvm/bin/clang-tblgen -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF -DCMAKE_SYSROOT=/sysroot .. &amp;&amp; \\    make -j32 &amp;&amp; make -j32 install    RUN cd /opt &amp;&amp; tar -zcf loongaarch64.tar.gz loongaarch64-llvm &amp;&amp; rm -rf /opt/loongaarch64-llvm/bin &amp;&amp; cp -r /opt/x86-llvm/bin /opt/loongaarch64-llvm &amp;&amp; rm -rf /opt/llvm-7.0.1ENV LLVM_INSTALL_DIR=/opt/x86-llvmRUN cd /opt/qt-everywhere-src-5.12.12/build &amp;&amp; cp -r /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-aarch64-gnu-g++ /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++ &amp;&amp; \\    sed -i &#x27;89c defined(__mips__) || defined(__loongarch__) || \\\\&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/src/3rdparty/double-conversion/include/double-conversion/utils.h &amp;&amp; \\    sed -i &#x27;14c QMAKE_CC          = loongarch64-linux-gnu-gcc&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;15c QMAKE_CXX         = loongarch64-linux-gnu-g++&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;16c QMAKE_LINK        = loongarch64-linux-gnu-g++&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;17c QMAKE_LINK_SHLIB  = loongarch64-linux-gnu-g++&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;20c QMAKE_AR          = loongarch64-linux-gnu-ar cqs&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;21c QMAKE_OBJCOPY     = loongarch64-linux-gnu-objcopy&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;22c QMAKE_NM          = loongarch64-linux-gnu-nm -P&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    sed -i &#x27;23c QMAKE_STRIP       = loongarch64-linux-gnu-strip&#x27; /opt/qt-everywhere-src-5.12.12/qtbase/mkspecs/linux-loongarch64-gnu-g++/qmake.conf &amp;&amp; \\    /opt/qt-everywhere-src-5.12.12/configure -prefix /qt5.12.12 \\    -opensource \\    -confirm-license \\    -release \\    -xplatform linux-loongarch64-gnu-g++ \\    -make libs \\    -make tools \\    -nomake tests \\    -nomake examples \\    -qt-zlib \\    -xcb-xlib -xcb \\    -opengl desktop \\    -sysroot /sysroot &amp;&amp; \\    make -j64 &amp;&amp; make -j32 installRUN rm -rf /opt/qt-everywhere-src-5.12.12ENV LLVM_INSTALL_DIR=/opt/loongaarch64-llvmENV QTC_ENABLE_CLANG_LIBTOOLING=trueENV PATH=$PATH:/sysroot/qt5.12.12/bin","slug":"Docker","date":"2024-02-22T08:03:32.000Z","categories_index":"","tags_index":"Docker","author_index":"哪吒"},{"id":"425d803af0b4bf31b2b7e015a65ed6f3","title":"会话技术","content":"\n\n\n\n\n\n\n\n\n💡 Tips：HTTP 的一大特点“无状态”，是其最初版本的设计特点之一，而这一特点一直保持到 HTTP 的最新版本。无状态意味着每个请求之间是相互独立的，服务器不会保存关于客户端请求的任何信息。这意味着每个请求都需要包含所有必要的信息，因此服务器可以理解并响应。\n虽然 HTTP 的无状态特性一直是保留下来的核心概念，但是随着时间的推移，HTTP 协议的演变和发展已经引入了一些机制来处理状态信息，比如 Cookie、Session 等机制。这些机制允许服务器和客户端在一系列请求之间共享状态信息，从而实现了在无状态协议中模拟有状态的行为。\n总的来说，尽管 HTTP 协议的基本无状态特性一直保持着，但随着技术的发展和需求的变化，HTTP 协议的实现和使用中引入了许多额外的功能和机制来处理状态信息，以满足现代网络应用的需求。\nCookieCookie 是客户端使用的一种记录客户端状态的机制，是由 W3C 组织提出，最早由 Netscape(网景) 社区发展的一种机制。目前 Cookie 已经成为标准，所有的主流浏览器基本都支持 Cookie。\nCookie 工作流程Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上：\n\n\n\n\n\n\n\n\n\n\n\n\n服务器端设置 Cookie： 当客户端向服务器发送请求时，服务器可以在 HTTP 响应消息报头中插入 Set-Cookie 标头，以设置 Cookie。Set-Cookie 标头包含了 Cookie 的名称、值以及其他可选的属性，如过期时间、域、路径等；\n客户端保存 Cookie： 客户端收到服务器发送的响应后，会将其中的 Set-Cookie 标头中的 Cookie 保存起来。如果 Cookie 设置了过期时间，那么它将会被持久地存储，直到到达过期时间；如果没有设置过期时间，那么它将只在客户端的内存中存储，并在关闭浏览器时被删除；\n客户端发送 Cookie： 当客户端向服务器发送新的请求时，它会自动在请求报头中插入所有与当前域相关联的 Cookie；\n服务器端读取 Cookie： 服务器收到客户端的请求后，可以通过读取请求报头中的 Cookie 来获取客户端发送的数据。服务器可以根据这些 Cookie 来识别用户状态、执行个性化操作等；\n\nCookie 应用场景\n个性化设置：如用户自定义设置、主题等；\n浏览器行为跟踪：如跟踪分析用户行为等；\n会话状态管理：如用户登录状态、购物车、游戏分数或其它需要记录的信息；\n\nCookie 一些细节\n\n\n\n\n\nTIP\n\n持久存储的 Cookie： 存储在客户端的磁盘上，因此可以在浏览器会话之间持续存在，即使关闭浏览器再打开也会继续存在。这种类型的 Cookie 可以通过设置过期时间来控制其持续时间，但它们不会跨越浏览器或设备边界，因为它们存储在本地文件系统中，每个浏览器和设备都有自己的本地文件系统，但通过 Cookie 导出导入可以做到跨浏览器和设备；\n非持久存储的 Cookie： 存储在客户端的内存中，通常在关闭浏览器时就会被销毁。这种 Cookie 通常用于临时性数据的存储，比如会话标识符等。因为它们只存储在内存中，并且会在浏览器关闭时被销毁，所以不能持久存在，也不会跨越浏览器或设备边界；\n存储大小限制： 每个 Cookie 的存储大小通常限制在 4KB 左右。这意味着单个 Cookie 的键值对及其相关的元数据（如过期时间、域、路径等）总共不能超过这个大小；\n最大 Cookie 数量限制： 一个浏览器通常会限制每个域名下的 Cookie 数量，一般不超过 300 个 Cookie。这个限制旨在防止网站过度使用 Cookie，以及减轻客户端存储的压力；\n单个网站 Cookie 数量限制：每个网站最多可以设置的 Cookie 数量通常也有限制，一般不超过 20 个。这个限制有助于确保网站不会过度依赖 Cookie 来存储大量数据，以及减少客户端存储的负担；\nCookie 同源策略：Cookie 同源策略允许在同一父级域名下共享 Cookie。这意味着当设置了一个 Cookie 的 “domain” 属性时，该 Cookie 将在指定的域名以及其所有的子域名下可见。因此，当访问子域名时，浏览器会发送父级域名下的 Cookie，使得跨子域名间可以共享用户状态信息；\n\n\n\nSessionSession 是一种服务器端的状态管理机制，用于存储和跟踪用户的会话信息。与 Cookie 不同，Session 数据存储在服务器端，而不是客户端。\nSession 工作流程Session 与 Cookie 有很大的相似，服务端最终响应给客户端的是一段 Cookie，从而可以说 Session 的实现依赖 Cookie：\n\n\n\n\n\n\n\n\n\n\n\n\n服务器创建 Session： 服务器为用户创建一个新的 Session，并生成一个唯一的 SessionID；\n发送 SessionID 给客户端： 服务器将 SessionID 放置在 Set-Cookie 标头中发送给客户端；\n客户端保存 SessionID： 客户端（浏览器）保存接收到的 SessionID；\n客户端发送请求并携带 SessionID： 客户端发送请求时，自动将保存的 SessionID 放置在请求的 Cookie 中发送给服务器；\n服务器根据 SessionID 获取数据： 服务器根据 SessionID 获取与用户相关的会话数据；\n服务器返回响应： 服务器根据请求处理结果生成响应并发送给客户端；\n\nSession 应用场景跟 Cookie 一样，没啥子差别。\nSession 一些细节\n\n\n\n\n\nTIP\n\n禁用了 Cookie 之后 Session 还可以用嘛？\nSession 实现关键是 SessionID，只需要将 SessionID 传递给浏览器，浏览器在请求的时候再将 SessionID 传递给服务器，就可以实现 Session；\n\n\n假如使用了 Nginx 服务器软件做了负载均衡，那么会发现丢失 Session 的问题。出现丢失 Session 问题怎么办呢？\n可以使用用 Nginx ip_hash 算法解决；\n\n\n\n\n\nSession 和 Cookie 的区别\n\n\n\n\n\nTIP\n\nSession 存储在服务端，Cookie 存储在客户端；\nSession 用户无法查看和修改，Cookie 用户可以查看修改；\nSession 和 Cookie 的存储容量不同，Cookie 有各种限制，Session 没有限制；\n\n\n\n","slug":"会话技术","date":"2024-02-22T05:56:20.000Z","categories_index":"","tags_index":"网络协议","author_index":"哪吒"},{"id":"44a298e41e961f01947480950600547b","title":"搞定 HTTP 协议","content":"\n\n\n\n\n\n\n\n\n💡 Tips：HTTP 协议（超文本传输协议 HyperText Transfer Protocol），是一种基于 TCP&#x2F;IP 协议的应用层协议，用于在客户端和服务器之间传输超文本文档，超文本文档可以包含各种内容：文本、图形、音频、视频、二进制文件等。\n历史版本\n\n\n\n\n\nTIP\n\n1991 年发布的 HTTP&#x2F;0.9 版本发布，该版本及其的简单，只有一个命令 GET ，且只支持文本传输；\n1996 年 5 月份， HTTP&#x2F;1.0 版本发布，内容大大的增加。可以传输任何格式的内容：文本、图形、音频、视频、二进制文件等。命令也进行了扩展，引入了 POST 和 HEAD 命令。但 1.0 版本存在一个缺点，不支持持久连接；\n1997 年 1 月，HTTP&#x2F;1.1 版本发布，进一步的完善了 HTTP 协议，也是现目前互联网使用最广泛的版本。1.1 版本最大的变化就是引入了持久连接；\n2015 年，HTTP&#x2F;2 发布。它不叫 HTTP&#x2F;2.0，因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP&#x2F;3 。3 版本的最大的改变，可能会抛弃掉 TCP 协议使用 UDP 协议；\n\n\n\n持久化与非持久化持久化（长连接）为了解决非持久连接的缺点，HTTP&#x2F;1.1 引入了持久连接的概念。在持久连接中，客户端和服务器之间的连接在一定的时间段内保持打开状态，可以在同一连接上发送多个请求和接收多个响应。这样做可以避免重复创建和关闭连接的开销，提高通信效率和性能。持久连接使得可以在一个连接上完成多个 HTTP 请求&#x2F;响应往返。\n非持久化（短连接）在 HTTP&#x2F;1.0 版本中，每次客户端发送请求给服务器时，都会创建一个新的 TCP 连接。这个连接在请求完成后会立即关闭。也就是说，每个请求和响应都需要独立的连接，这种方式被称为非持久连接。这种方法的缺点是，每次创建和关闭连接都需要时间和资源，会增加通信的延迟和消耗。\n持久化优缺点\n优点\n减少延迟： 可以在同一连接上连续发送多个请求和接收多个响应，减少了连接建立和关闭的开销，提高了通信的效率和性能；\n节省资源： 保持连接打开可以避免重复的连接建立和关闭，节省了服务器和客户端的连接资源；\n提高吞吐量： 长连接可以在一定程度上提高系统的吞吐量，特别是在大量并发请求的情况下；\n\n\n缺点\n资源占用： 长时间保持连接打开会占用服务器和客户端的连接资源，可能会导致资源的浪费；\n管理复杂性： 长连接需要管理连接的生命周期和状态，增加了系统的管理和维护成本；\n占用连接数： 长连接会占用一定数量的连接数，可能会影响其他用户的访问和系统的可用性；\n\n\n\n非持久化优缺点\n优点\n资源释放： 每个请求完成后立即关闭连接，释放了服务器和客户端的连接资源，有助于节省资源；\n独立性： 每个请求和响应都使用独立的连接，相互独立，不会相互影响，有助于提高系统的稳定性；\n灵活性： 适用于对延迟要求严格、资源受限或需要相对独立的场景；\n\n\n缺点\n连接开销： 频繁地创建和关闭连接会增加通信的延迟和资源消耗，降低了通信的效率；\n性能下降： 每次建立连接都需要进行三次握手，增加了网络延迟，降低了性能；\n服务器负载： 大量的连接创建和关闭会增加服务器的负载，影响系统的性能和吞吐量；\n\n\n\n注意事项\n无论是持久连接还是非持久连接，在建立 TCP 连接和关闭 TCP 连接时都需要遵循 TCP 的三次握手和四次挥手过程； \nNginx 默认的持久连接超时时间为 75 秒，keepalive_timeout 可以设置持久连接的超时时间，如果客户端和服务器之间在设置的时间内没有任何活动，则 Nginx 会关闭持久连接；\n\n初识传输层协议在计算机网络中，应用层协议通常是建立在传输层协议之上的，这种关系通常被称为协议栈或协议堆叠。应用层协议利用传输层协议提供的服务来实现通信的目的。在继续深入 HTTP 协议前，有必要先看下网络组成图：\n\n\nTCP 传输控制协议\nTCP 是一种面向连接的协议，这意味着在发送数据之前，通信的两端需要建立一个连接；\n它提供可靠的数据传输，通过使用确认、重传、校验和流量控制等机制，确保数据的可靠性和完整性。如果数据在传输过程中丢失或损坏，TCP 将负责重新发送数据，直到接收到正确的数据为止；\nTCP 是一种流式协议（STREAM），数据被视为一连串的字节流，因此它保证了数据的顺序传输；\n在连接的建立和断开过程中，TCP 使用了三次握手和四次挥手的机制，以确保双方都同意建立或断开连接；\n\nUDP 用户数据协议\nUDP 是一种无连接的协议，通信的两端在传输数据之前不需要建立连接；\n它提供了一种简单的数据传输机制，不保证数据的可靠性或顺序传输。如果数据在传输过程中丢失或损坏，UDP 不会进行重传，而是直接丢弃这些数据；\nUDP 适用于一些对实时性要求高、对数据可靠性要求较低的应用，比如音频、视频传输等；\n由于不需要建立连接和维护状态信息，UDP 的开销比 TCP 小，传输速度相对更快；\n\nTCP 应用场景\n网页浏览：当你在浏览网页时，通常会使用 TCP 协议。因为网页的数据传输需要保证数据的完整性和顺序性，这样才能确保页面元素的正确加载和显示；\n电子邮件：发送和接收电子邮件时也通常使用 TCP。电子邮件的传输需要确保邮件内容的完整性，而且邮件的顺序也很重要，所以 TCP 协议是一个合适的选择。\n文件传输：在需要可靠地传输大文件的场景下，TCP 是首选。FTP（文件传输协议）等文件传输服务通常使用 TCP 协议，因为它能够确保文件的完整传输，而且对传输顺序有要求；\n远程登录：SSH（Secure Shell）等远程登录服务通常使用 TCP。远程登录需要确保传输的命令和输出是可靠的，并且需要保持会话的状态；\n\nUDP 应用场景\n实时视频&#x2F;音频传输：视频会议、在线直播等实时应用通常使用 UDP 协议。在这些应用中，实时性比数据的完整性更加重要，因此可以使用 UDP 以减少传输延迟；\n实时游戏：在线游戏通常使用 UDP 进行通信，因为在游戏中延迟是非常关键的，而 UDP 能够提供更低的传输延迟，并且允许丢失部分数据而不会导致整个通信阻塞；\nDNS（域名系统）查询：DNS 查询也常常使用 UDP 协议。虽然 DNS 查询需要准确的返回结果，但由于查询通常很小且响应时间敏感，因此 UDP 的简单性和低延迟使其成为了首选；\nSNMP（简单网络管理协议）：网络管理中的 SNMP 通常使用 UDP。尽管管理信息的准确性很重要，但由于 SNMP 的查询通常是小且频繁的，UDP 提供了更好的性能和效率；\n\n三次握手三次握手是 TCP 协议中用于建立连接的过程，确保了通信的可靠性和正确性，上图：\n\n\n\n第一次握手（SYN） \n客户端向服务器发送一个带有 SYN 标志的数据包，表示客户端请求建立连接，并指定一个初始序列号；\n\n\n第二次握手（SYN + ACK） \n服务器收到客户端的 SYN 数据包后，会发送一个带有 SYN 和 ACK 标志的数据包作为响应，表示确认收到连接请求，并且也指定一个初始序列号；\n\n\n第三次握手（ACK） \n客户端收到服务器的响应后，会发送一个带有 ACK 标志的数据包作为确认，表示确认收到服务器的响应，连接建立成功；\n\n\n\n四次挥手四次挥手是 TCP 协议中用于关闭连接的过程，确保了双方在断开连接时的可靠性，上图：\n\n\n\n第一次挥手（FIN） \n客户端向服务器发送一个带有 FIN（结束）标志的数据包，表示客户端不再发送数据，但仍然可以接收数据；\n\n\n第二次挥手（ACK） \n服务器收到客户端的 FIN 数据包后，会发送一个带有 ACK（确认）标志的数据包作为响应，表示确认收到客户端的关闭请求；\n\n\n第三次挥手（FIN） \n服务器在发送完所有数据后，会向客户端发送一个带有 FIN 标志的数据包，表示服务器也准备关闭连接；\n\n\n第四次挥手（ACK） \n客户端收到服务器的 FIN 数据包后，会发送一个带有 ACK 标志的数据包作为响应，表示确认收到服务器的关闭请求，连接关闭；\n\n\n\nTCP&#x2F;IP 通信传输流利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下：\n\n\nHTTP 工作流程当浏览器（客户端）想要获取某个站点（服务端）网页时，它会按照以下步骤执行 HTTP 工作流程：\n\n\n\n\n\n\n\n\nTIP\n\n解析URL： \n用户在浏览器中输入 URL（统一资源定位符）；\n浏览器解析 URL，提取出协议、域名和路径等信息；\n\n\nDNS解析： \n浏览器发起 DNS 解析请求，将域名解析成服务器的 IP 地址；\n浏览器获取到服务器的 IP 地址后，就可以发起与服务器的连接了；\n\n\n建立TCP连接： \n浏览器使用 HTTP 协议建立 TCP 连接到服务器；\n这是通过三次握手来建立可靠的连接；\n\n\n发送HTTP请求： \n浏览器向服务器发送 HTTP 请求；\nHTTP 请求中包含了请求的方法（GET、POST等）、请求头和请求体等信息；\n\n\n服务器处理请求： \n服务器接收到浏览器发送的 HTTP 请求后，根据请求的路径和方法等信息，处理请求；\n服务器可能会查询数据库、执行业务逻辑等，然后准备好需要发送给浏览器的 HTTP 响应；\n\n\n发送HTTP响应： \n服务器将准备好的 HTTP 响应发送给浏览器；\nHTTP 响应中包含了响应的状态码、响应头和响应体等信息；\n\n\n接收HTTP响应： \n浏览器接收到服务器发送的 HTTP 响应后，开始处理响应；\n浏览器会根据响应的内容类型等信息，决定如何处理响应；\n\n\n渲染页面： \n如果响应的内容是 HTML 页面，浏览器会解析 HTML 代码，并根据 CSS 样式表和 JavaScript 脚本等进行页面布局和渲染；\n如果接收的 HTTP 响应是 API 接口响应。浏览器不需要渲染 HTML 页面，而是处理接收到的 JSON 或其他数据格式的响应，然后根据前端逻辑进行相应的处理；\n浏览器会将渲染后的页面呈现给用户，用户就可以在浏览器中看到网页内容了；\n\n\n关闭连接： \n当页面加载完成后，浏览器会关闭与服务器的 TCP 连接，释放资源；\n\n\n\n\n\n什么是 HTTP 事务？一次 HTTP 完整的工作流程步骤很多，重点关注在于请求与响应组合而成的 HTTP 事务。HTTP 事务 &#x3D; 请求命令 + 响应结果。简单说就是一次完整的请求过程，包括请求的发送和结果的返回，如果只有发送请求，而没有响应结果，则不能算作 HTTP 事务。\nHTTP 请求123456789POST /submit-form HTTP/1.1ost: www.example.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: en-US,en;q=0.9Content-Type: application/x-www-form-urlencodedContent-Length: 29username=user&amp;password=pass123\n\n\n\n\n\n\n\n\n\n\n请求报文可以分为三部分：\n\n请求行（Request Line）包括请求的命令、资源的路径和协议版本；\n请求头部（Request Headers）包括了一系列的键值对，用来描述请求的一些附加信息；\n请求体（Request Body）对于 GET 请求，通常为空，因为 GET 请求不包含请求体。对于其他一些请求方法（如POST、PUT等），请求体可能包含一些自定义数据或内容；\n\n请求命令\n\n\n命令\n描述\n\n\n\nGET\n请求指定的页面信息，并返回实体主体\n\n\nPOST\n向指定资源提交数据进行处理请求\n\n\nPUT\n向指定资源位置上传新的实体主体\n\n\nDELETE\n请求服务器删除指定的页面\n\n\nHEAD\n类似于GET请求，只不过返回的响应中没有具体的内容，用于获取资源的元信息\n\n\nPATCH\n对资源进行部分修改\n\n\nOPTIONS\n请求服务器告知其支持的HTTP方法\n\n\n请求头\n\n\nHeader\n描述\n示例\n\n\n\nAccept\n告诉服务器，客户端支持的数据类型。\nAccept: text&#x2F;plain, text&#x2F;html\n\n\nAccept-Charset\n告诉服务器，客户端采用的编码。\nAccept-Charset: iso-8859-5,utf-8\n\n\nAccept-Encoding\n告诉服务器，客户机支持的数据压缩格式。\nAccept-Encoding: compress, gzip\n\n\nAccept-Language\n告诉服务器，客户机的语言环境。\nAccept-Language: en,zh\n\n\nAccept-Ranges\n可以请求网页实体的一个或者多个子范围字段\nAccept-Ranges: bytes\n\n\nAuthorization\nHTTP授权的授权证书类型\nAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;\n\n\nCache-Control\n指定请求和响应遵循的缓存机制\nCache-Control: no-cache\n\n\nConnection\n表示是否需要持久连接（HTTP 1.1默认进行持久连接）\nKeep-Alive\n\n\nCookie\nHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器\nCookie: $Version&#x3D;1; Skin&#x3D;new;\n\n\nContent-Length\n请求的内容长度\nContent-Length: 348\n\n\nContent-Type\n请求的与实体对应的MIME信息\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\nDate\n请求发送的日期和时间\nDate: Tue, 15 Nov 2010 08:12:31 GMT\n\n\nExpect\n请求的特定的服务器行为\nExpect: 100-continue\n\n\nFrom\n发出请求的用户的Email\nFrom: xxx@163.com\n\n\nHost\n指定请求的服务器的域名和端口号\nHost: www.baidu.com\n\n\nIf-Match\n只有请求内容与实体相匹配才有效\nIf-Match: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Modified-Since\n客户机通过这个头告诉服务器，资源的缓存时间。\nIf-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT\n\n\nIf-None-Match\n如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变\nIf-None-Match: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Range\n如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag\nIf-Range: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Unmodified-Since\n只在实体在指定时间之后未被修改才请求成功\nIf-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT\n\n\nMax-Forwards\n限制信息通过代理和网关传送的时间\nMax-Forwards: 10\n\n\nPragma\n用来包含实现特定的指令\nPragma: no-cache\n\n\nProxy-Authorization\n连接到代理的授权证书\nProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;\n\n\nRange\n只请求实体的一部分，指定范围\nRange: bytes&#x3D;500-999\n\n\nReferer\n客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的。（一般用于防盗链）\nReferer: www.zcmhi.com/archives/71…\n\n\nTE\n客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息\nTE: trailers,deflate;q&#x3D;0.5\n\n\nUpgrade\n向服务器指定某种传输协议以便服务器进行转换（如果支持）\nUpgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11\n\n\nUser-Agent\n浏览器的具体信息\nUser-Agent: Mozilla&#x2F;5.0 (Linux; X11)\n\n\nVia\n通知中间网关或代理服务器地址，通信协议\nVia: 1.0 fred, 1.1 nowhere.com\n\n\n(Apache&#x2F;1.1)\n\n\n\n\nWarning\n关于消息实体的警告信息\nWarn: 199 Miscellaneous warning\n\n\nHTTP 响应12345678910HTTP/1.1 200 OKDate: Sat, 01 Jan 2022 12:00:00 GMTServer: Apache/2.4.41 (Unix)Content-Type: application/jsonContent-Length: 56&#123;    &quot;message&quot;: &quot;Hello, world!&quot;,    &quot;status&quot;: &quot;success&quot;&#125;\n\n\n\n\n\n\n\nTIP\n响应报文可以分为三部分：\n\n响应行（Status Line）包括了协议版本、状态码和状态消息；\n响应头部（Response Headers）包括了一系列的键值对，用来描述响应的一些附加信息；\n响应体（Response Body）包含了响应的实际内容；\n\n\n\n状态码\n\n\n状态码\n描述\n\n\n\n1xx\n指示信息 - 表示请求已接收，继续处理\n\n\n100\n客户必须继续发出请求。\n\n\n101\n客户要求服务器根据请求转换 HTTP 协议版本。\n\n\n2xx\n成功 - 表示请求已被成功接收、理解、接受\n\n\n200\n（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n\n\n201\n（已创建） 请求成功并且服务器创建了新的资源。\n\n\n202\n（已接受） 服务器已接受请求，但尚未处理。\n\n\n3xx\n重定向 - 要完成请求必须进行更进一步的操作\n\n\n300\n（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者选择一项操作，或提供操作列表供请求者选择。\n\n\n301\n（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。\n\n\n302\n（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n\n\n4xx\n客户端错误 - 请求有语法错误或请求无法实现\n\n\n400\n（错误请求） 服务器不理解请求的语法。\n\n\n401\n（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n\n\n403\n（禁止） 服务器拒绝请求。\n\n\n5xx\n服务器端错误 - 服务器未能实现合法的请求\n\n\n500\n（服务器内部错误） 服务器遇到错误，无法完成请求。\n\n\n501\n（尚未实施） 服务器不具备完成请求的功能。\n\n\n502\n（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n\n\n503\n（服务不可用） 服务器目前无法使用。 通常，这只是暂时状态。\n\n\n504\n（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n\n\n505\n（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\n\n\n响应头\n\n\nHeader\n描述\n示例\n\n\n\nAccept-Ranges\n表明服务器是否支持指定范围请求及哪种类型的分段请求\nAccept-Ranges: bytes\n\n\nAge\n从原始服务器到代理缓存形成的估算时间（以秒计，非负）\nAge: 12\n\n\nAllow\n对某网络资源的有效的请求行为，不允许则返回405\nAllow: GET, HEAD\n\n\nCache-Control\n告诉所有的缓存机制是否可以缓存及哪种类型\nCache-Control: no-cache\n\n\nContent-Encoding\nweb服务器支持的返回内容压缩编码类型。\nContent-Encoding: gzip\n\n\nContent-Language\n响应体的语言\nContent-Language: en,zh\n\n\nContent-Length\n响应体的长度\nContent-Length: 348\n\n\nContent-Location\n请求资源可替代的备用的另一地址\nContent-Location: &#x2F;index.htm\n\n\nContent-MD5\n返回资源的MD5校验值\nContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ&#x3D;&#x3D;\n\n\nContent-Range\n在整个返回体中本部分的字节位置\nContent-Range: bytes 21010-47021&#x2F;47022\n\n\nContent-Type\n如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码\nContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n\nDate\n原始服务器消息发出的时间\nDate: Tue, 15 Nov 2010 08:12:31 GMT\n\n\nETag\n请求变量的实体标签的当前值\nETag: “737060cd8c284d8af7ad3082f209582d”\n\n\nExpires\n响应过期的日期和时间\nExpires: Thu, 01 Dec 2010 16:00:00 GMT\n\n\nLast-Modified\n请求资源的最后修改时间\nLast-Modified: Tue, 15 Nov 2010 12:45:26 GMT\n\n\nLocation\n用来重定向接收方到非请求URL的位置来完成请求或标识新的资源\nLocation: http://www.zcmhi.com/archives/94.html\n\n\nPragma\n包括实现特定的指令，它可应用到响应链上的任何接收方\nPragma: no-cache\n\n\nProxy-Authenticate\n它指出认证方案和可应用到代理的该URL上的参数\nProxy-Authenticate: Basic\n\n\nrefresh\n应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）\nRefresh: 5; url&#x3D;http://www.zcmhi.com/archives/94.html\n\n\nRetry-After\n如果实体暂时不可取，通知客户端在指定时间之后再次尝试\nRetry-After: 120\n\n\nServer\nweb服务器软件名称\nServer: Apache&#x2F;1.3.27 (Unix) (Red-Hat&#x2F;Linux)\n\n\nSet-Cookie\n设置Http Cookie\nSet-Cookie: UserID&#x3D;JohnDoe; Max-Age&#x3D;3600; Version&#x3D;1\n\n\nTrailer\n指出头域在分块传输编码的尾部存在\nTrailer: Max-Forwards\n\n\nTransfer-Encoding\n文件传输编码\nTransfer-Encoding:chunked\n\n\nVary\n告诉下游代理是使用缓存响应还是从原始服务器请求\nVary: *\n\n\nVia\n告知代理客户端响应是通过哪里发送的\nVia: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1)\n\n\nWarning\n警告实体可能存在的问题\nWarning: 199 Miscellaneous warning\n\n\nWWW-Authenticate\n表明客户端请求实体应该使用的授权方案\nWWW-Authenticate: Basic\n\n\n","slug":"搞定-HTTP-协议","date":"2024-02-18T09:19:57.000Z","categories_index":"","tags_index":"网络协议","author_index":"哪吒"}]