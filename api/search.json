[{"id":"44a298e41e961f01947480950600547b","title":"搞定 HTTP 协议","content":":::info💡 Tips：HTTP 协议（超文本传输协议 HyperText Transfer Protocol），是一种基于 TCP&#x2F;IP 协议的应用层协议，用于在客户端和服务器之间传输超文本文档，超文本文档可以包含各种内容：文本、图形、音频、视频、二进制文件等。:::\n历史版本\n1991 年发布的 HTTP&#x2F;0.9 版本发布，该版本及其的简单，只有一个命令 GET ，且只支持文本传输；\n1996 年 5 月份， HTTP&#x2F;1.0 版本发布，内容大大的增加。可以传输任何格式的内容：文本、图形、音频、视频、二进制文件等。命令也进行了扩展，引入了 POST 和 HEAD 命令。但 1.0 版本存在一个缺点，不支持持久连接；\n1997 年 1 月，HTTP&#x2F;1.1 版本发布，进一步的完善了 HTTP 协议，也是现目前互联网使用最广泛的版本。1.1 版本最大的变化就是引入了持久连接；\n2015 年，HTTP&#x2F;2 发布。它不叫 HTTP&#x2F;2.0，因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP&#x2F;3 。3 版本的最大的改变，可能会抛弃掉 TCP 协议使用 UDP 协议；\n\n持久化与非持久化\n持久化（长连接）为了解决非持久连接的缺点，HTTP&#x2F;1.1 引入了持久连接的概念。在持久连接中，客户端和服务器之间的连接在一定的时间段内保持打开状态，可以在同一连接上发送多个请求和接收多个响应。这样做可以避免重复创建和关闭连接的开销，提高通信效率和性能。持久连接使得可以在一个连接上完成多个 HTTP 请求&#x2F;响应往返。\n非持久化（短连接）在 HTTP&#x2F;1.0 版本中，每次客户端发送请求给服务器时，都会创建一个新的 TCP 连接。这个连接在请求完成后会立即关闭。也就是说，每个请求和响应都需要独立的连接，这种方式被称为非持久连接。这种方法的缺点是，每次创建和关闭连接都需要时间和资源，会增加通信的延迟和消耗。\n持久化优缺点\n优点\n减少延迟： 可以在同一连接上连续发送多个请求和接收多个响应，减少了连接建立和关闭的开销，提高了通信的效率和性能；\n节省资源： 保持连接打开可以避免重复的连接建立和关闭，节省了服务器和客户端的连接资源；\n提高吞吐量： 长连接可以在一定程度上提高系统的吞吐量，特别是在大量并发请求的情况下；\n\n\n缺点\n资源占用： 长时间保持连接打开会占用服务器和客户端的连接资源，可能会导致资源的浪费；\n管理复杂性： 长连接需要管理连接的生命周期和状态，增加了系统的管理和维护成本；\n占用连接数： 长连接会占用一定数量的连接数，可能会影响其他用户的访问和系统的可用性； \n\n\n\n非持久化优缺点\n优点\n资源释放： 每个请求完成后立即关闭连接，释放了服务器和客户端的连接资源，有助于节省资源；\n独立性： 每个请求和响应都使用独立的连接，相互独立，不会相互影响，有助于提高系统的稳定性；\n灵活性： 适用于对延迟要求严格、资源受限或需要相对独立的场景；\n\n\n缺点\n连接开销： 频繁地创建和关闭连接会增加通信的延迟和资源消耗，降低了通信的效率；\n性能下降： 每次建立连接都需要进行三次握手，增加了网络延迟，降低了性能；\n服务器负载： 大量的连接创建和关闭会增加服务器的负载，影响系统的性能和吞吐量； \n\n\n\n注意事项\n无论是持久连接还是非持久连接，在建立 TCP 连接和关闭 TCP 连接时都需要遵循 TCP 的三次握手和四次挥手过程； \nNginx 默认的持久连接超时时间为 75 秒，keepalive_timeout 可以设置持久连接的超时时间，如果客户端和服务器之间在设置的时间内没有任何活动，则 Nginx 会关闭持久连接；\n\n初识传输层协议在计算机网络中，应用层协议通常是建立在传输层协议之上的，这种关系通常被称为协议栈或协议堆叠。应用层协议利用传输层协议提供的服务来实现通信的目的。在继续深入 HTTP 协议前，有必要先看下网络组成图：\n\n\n\nTCP 传输控制协议\nTCP 是一种面向连接的协议，这意味着在发送数据之前，通信的两端需要建立一个连接；\n它提供可靠的数据传输，通过使用确认、重传、校验和流量控制等机制，确保数据的可靠性和完整性。如果数据在传输过程中丢失或损坏，TCP 将负责重新发送数据，直到接收到正确的数据为止；\nTCP 是一种流式协议（STREAM），数据被视为一连串的字节流，因此它保证了数据的顺序传输；\n在连接的建立和断开过程中，TCP 使用了三次握手和四次挥手的机制，以确保双方都同意建立或断开连接；\n\nUDP 用户数据协议\nUDP 是一种无连接的协议，通信的两端在传输数据之前不需要建立连接；\n它提供了一种简单的数据传输机制，不保证数据的可靠性或顺序传输。如果数据在传输过程中丢失或损坏，UDP 不会进行重传，而是直接丢弃这些数据；\nUDP 适用于一些对实时性要求高、对数据可靠性要求较低的应用，比如音频、视频传输等；\n由于不需要建立连接和维护状态信息，UDP 的开销比 TCP 小，传输速度相对更快；\n\nTCP 应用场景\n网页浏览：当你在浏览网页时，通常会使用 TCP 协议。因为网页的数据传输需要保证数据的完整性和顺序性，这样才能确保页面元素的正确加载和显示；\n电子邮件：发送和接收电子邮件时也通常使用 TCP。电子邮件的传输需要确保邮件内容的完整性，而且邮件的顺序也很重要，所以 TCP 协议是一个合适的选择。\n文件传输：在需要可靠地传输大文件的场景下，TCP 是首选。FTP（文件传输协议）等文件传输服务通常使用 TCP 协议，因为它能够确保文件的完整传输，而且对传输顺序有要求；\n远程登录：SSH（Secure Shell）等远程登录服务通常使用 TCP。远程登录需要确保传输的命令和输出是可靠的，并且需要保持会话的状态；\n\nUDP 应用场景\n实时视频&#x2F;音频传输：视频会议、在线直播等实时应用通常使用 UDP 协议。在这些应用中，实时性比数据的完整性更加重要，因此可以使用 UDP 以减少传输延迟；\n实时游戏：在线游戏通常使用 UDP 进行通信，因为在游戏中延迟是非常关键的，而 UDP 能够提供更低的传输延迟，并且允许丢失部分数据而不会导致整个通信阻塞；\nDNS（域名系统）查询：DNS 查询也常常使用 UDP 协议。虽然 DNS 查询需要准确的返回结果，但由于查询通常很小且响应时间敏感，因此 UDP 的简单性和低延迟使其成为了首选；\nSNMP（简单网络管理协议）：网络管理中的 SNMP 通常使用 UDP。尽管管理信息的准确性很重要，但由于 SNMP 的查询通常是小且频繁的，UDP 提供了更好的性能和效率；\n\n三次握手三次握手是 TCP 协议中用于建立连接的过程，确保了通信的可靠性和正确性，上图：\n\n\n\n第一次握手（SYN） \n客户端向服务器发送一个带有 SYN 标志的数据包，表示客户端请求建立连接，并指定一个初始序列号；\n\n\n第二次握手（SYN + ACK） \n服务器收到客户端的 SYN 数据包后，会发送一个带有 SYN 和 ACK 标志的数据包作为响应，表示确认收到连接请求，并且也指定一个初始序列号；\n\n\n第三次握手（ACK） \n客户端收到服务器的响应后，会发送一个带有 ACK 标志的数据包作为确认，表示确认收到服务器的响应，连接建立成功；\n\n\n\n四次挥手四次挥手是 TCP 协议中用于关闭连接的过程，确保了双方在断开连接时的可靠性，上图：\n\n\n\n第一次挥手（FIN） \n客户端向服务器发送一个带有 FIN（结束）标志的数据包，表示客户端不再发送数据，但仍然可以接收数据；\n\n\n第二次挥手（ACK） \n服务器收到客户端的 FIN 数据包后，会发送一个带有 ACK（确认）标志的数据包作为响应，表示确认收到客户端的关闭请求；\n\n\n第三次挥手（FIN） \n服务器在发送完所有数据后，会向客户端发送一个带有 FIN 标志的数据包，表示服务器也准备关闭连接；\n\n\n第四次挥手（ACK） \n客户端收到服务器的 FIN 数据包后，会发送一个带有 ACK 标志的数据包作为响应，表示确认收到服务器的关闭请求，连接关闭；\n\n\n\nTCP&#x2F;IP 通信传输流利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下：\n\n\n\nHTTP 工作流程当浏览器（客户端）想要获取某个站点（服务端）网页时，它会按照以下步骤执行 HTTP 工作流程：\n\n\n:::info\n\n解析URL： \n用户在浏览器中输入 URL（统一资源定位符）；\n浏览器解析 URL，提取出协议、域名和路径等信息；\n\n\nDNS解析： \n浏览器发起 DNS 解析请求，将域名解析成服务器的 IP 地址；\n浏览器获取到服务器的 IP 地址后，就可以发起与服务器的连接了；\n建立TCP连接： \n浏览器使用 HTTP 协议建立 TCP 连接到服务器；\n这是通过三次握手来建立可靠的连接；\n发送HTTP请求： \n浏览器向服务器发送 HTTP 请求；\nHTTP 请求中包含了请求的方法（GET、POST等）、请求头和请求体等信息；\n服务器处理请求： \n服务器接收到浏览器发送的 HTTP 请求后，根据请求的路径和方法等信息，处理请求；\n服务器可能会查询数据库、执行业务逻辑等，然后准备好需要发送给浏览器的 HTTP 响应；\n发送HTTP响应： \n服务器将准备好的 HTTP 响应发送给浏览器；\nHTTP 响应中包含了响应的状态码、响应头和响应体等信息；\n接收HTTP响应： \n浏览器接收到服务器发送的 HTTP 响应后，开始处理响应；\n浏览器会根据响应的内容类型等信息，决定如何处理响应；\n渲染页面： \n如果响应的内容是 HTML 页面，浏览器会解析 HTML 代码，并根据 CSS 样式表和 JavaScript 脚本等进行页面布局和渲染；\n如果接收的 HTTP 响应是 API 接口响应。浏览器不需要渲染 HTML 页面，而是处理接收到的 JSON 或其他数据格式的响应，然后根据前端逻辑进行相应的处理；\n浏览器会将渲染后的页面呈现给用户，用户就可以在浏览器中看到网页内容了；\n关闭连接： \n当页面加载完成后，浏览器会关闭与服务器的 TCP 连接，释放资源；   :::   \n\n什么是 HTTP 事务？一次 HTTP 完整的工作流程步骤很多，重点关注在于请求与响应组合而成的 HTTP 事务。HTTP 事务 &#x3D; 请求命令 + 响应结果。简单说就是一次完整的请求过程，包括请求的发送和结果的返回，如果只有发送请求，而没有响应结果，则不能算作 HTTP 事务。\nHTTP 请求123456789POST /submit-form HTTP/1.1ost: www.example.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: en-US,en;q=0.9Content-Type: application/x-www-form-urlencodedContent-Length: 29username=user&amp;password=pass123\n\n\n\n\n\n\n\n\n\n请求报文可以分为三部分：\n\n请求行（Request Line）包括请求的命令、资源的路径和协议版本；\n请求头部（Request Headers）包括了一系列的键值对，用来描述请求的一些附加信息；\n请求体（Request Body）对于 GET 请求，通常为空，因为 GET 请求不包含请求体。对于其他一些请求方法（如POST、PUT等），请求体可能包含一些自定义数据或内容；\n\n\n请求命令\n\n\n命令\n描述\n\n\n\nGET\n请求指定的页面信息，并返回实体主体\n\n\nPOST\n向指定资源提交数据进行处理请求\n\n\nPUT\n向指定资源位置上传新的实体主体\n\n\nDELETE\n请求服务器删除指定的页面\n\n\nHEAD\n类似于GET请求，只不过返回的响应中没有具体的内容，用于获取资源的元信息\n\n\nPATCH\n对资源进行部分修改\n\n\nOPTIONS\n请求服务器告知其支持的HTTP方法\n\n\n\n请求头\n\n\nHeader\n描述\n示例\n\n\n\nAccept\n告诉服务器，客户端支持的数据类型。\nAccept: text&#x2F;plain, text&#x2F;html\n\n\nAccept-Charset\n告诉服务器，客户端采用的编码。\nAccept-Charset: iso-8859-5,utf-8\n\n\nAccept-Encoding\n告诉服务器，客户机支持的数据压缩格式。\nAccept-Encoding: compress, gzip\n\n\nAccept-Language\n告诉服务器，客户机的语言环境。\nAccept-Language: en,zh\n\n\nAccept-Ranges\n可以请求网页实体的一个或者多个子范围字段\nAccept-Ranges: bytes\n\n\nAuthorization\nHTTP授权的授权证书类型\nAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;\n\n\nCache-Control\n指定请求和响应遵循的缓存机制\nCache-Control: no-cache\n\n\nConnection\n表示是否需要持久连接（HTTP 1.1默认进行持久连接）\nKeep-Alive\n\n\nCookie\nHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器\nCookie: $Version&#x3D;1; Skin&#x3D;new;\n\n\nContent-Length\n请求的内容长度\nContent-Length: 348\n\n\nContent-Type\n请求的与实体对应的MIME信息\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\nDate\n请求发送的日期和时间\nDate: Tue, 15 Nov 2010 08:12:31 GMT\n\n\nExpect\n请求的特定的服务器行为\nExpect: 100-continue\n\n\nFrom\n发出请求的用户的Email\nFrom: xxx@163.com\n\n\nHost\n指定请求的服务器的域名和端口号\nHost: www.baidu.com\n\n\nIf-Match\n只有请求内容与实体相匹配才有效\nIf-Match: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Modified-Since\n客户机通过这个头告诉服务器，资源的缓存时间。\nIf-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT\n\n\nIf-None-Match\n如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变\nIf-None-Match: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Range\n如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag\nIf-Range: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Unmodified-Since\n只在实体在指定时间之后未被修改才请求成功\nIf-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT\n\n\nMax-Forwards\n限制信息通过代理和网关传送的时间\nMax-Forwards: 10\n\n\nPragma\n用来包含实现特定的指令\nPragma: no-cache\n\n\nProxy-Authorization\n连接到代理的授权证书\nProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;\n\n\nRange\n只请求实体的一部分，指定范围\nRange: bytes&#x3D;500-999\n\n\nReferer\n客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的。（一般用于防盗链）\nReferer: www.zcmhi.com/archives/71…\n\n\nTE\n客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息\nTE: trailers,deflate;q&#x3D;0.5\n\n\nUpgrade\n向服务器指定某种传输协议以便服务器进行转换（如果支持）\nUpgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11\n\n\nUser-Agent\n浏览器的具体信息\nUser-Agent: Mozilla&#x2F;5.0 (Linux; X11)\n\n\nVia\n通知中间网关或代理服务器地址，通信协议\nVia: 1.0 fred, 1.1 nowhere.com(Apache&#x2F;1.1)\n\n\nWarning\n关于消息实体的警告信息\nWarn: 199 Miscellaneous warning\n\n\n\nHTTP 响应12345678910HTTP/1.1 200 OKDate: Sat, 01 Jan 2022 12:00:00 GMTServer: Apache/2.4.41 (Unix)Content-Type: application/jsonContent-Length: 56&#123;    &quot;message&quot;: &quot;Hello, world!&quot;,    &quot;status&quot;: &quot;success&quot;&#125;\n:::danger响应报文可以分为三部分：\n\n响应行（Status Line）包括了协议版本、状态码和状态消息；\n响应头部（Response Headers）包括了一系列的键值对，用来描述响应的一些附加信息；\n响应体（Response Body）包含了响应的实际内容；:::\n\n状态码\n\n\n状态码\n描述\n\n\n\n1xx\n指示信息 - 表示请求已接收，继续处理\n\n\n100\n客户必须继续发出请求。\n\n\n101\n客户要求服务器根据请求转换 HTTP 协议版本。\n\n\n2xx\n成功 - 表示请求已被成功接收、理解、接受\n\n\n200\n（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n\n\n201\n（已创建） 请求成功并且服务器创建了新的资源。\n\n\n202\n（已接受） 服务器已接受请求，但尚未处理。\n\n\n3xx\n重定向 - 要完成请求必须进行更进一步的操作\n\n\n300\n（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者选择一项操作，或提供操作列表供请求者选择。\n\n\n301\n（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。\n\n\n302\n（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n\n\n4xx\n客户端错误 - 请求有语法错误或请求无法实现\n\n\n400\n（错误请求） 服务器不理解请求的语法。\n\n\n401\n（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n\n\n403\n（禁止） 服务器拒绝请求。\n\n\n5xx\n服务器端错误 - 服务器未能实现合法的请求\n\n\n500\n（服务器内部错误） 服务器遇到错误，无法完成请求。\n\n\n501\n（尚未实施） 服务器不具备完成请求的功能。\n\n\n502\n（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n\n\n503\n（服务不可用） 服务器目前无法使用。 通常，这只是暂时状态。\n\n\n504\n（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n\n\n505\n（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\n\n\n\n响应头\n\n\nHeader\n描述\n示例\n\n\n\nAccept-Ranges\n表明服务器是否支持指定范围请求及哪种类型的分段请求\nAccept-Ranges: bytes\n\n\nAge\n从原始服务器到代理缓存形成的估算时间（以秒计，非负）\nAge: 12\n\n\nAllow\n对某网络资源的有效的请求行为，不允许则返回405\nAllow: GET, HEAD\n\n\nCache-Control\n告诉所有的缓存机制是否可以缓存及哪种类型\nCache-Control: no-cache\n\n\nContent-Encoding\nweb服务器支持的返回内容压缩编码类型。\nContent-Encoding: gzip\n\n\nContent-Language\n响应体的语言\nContent-Language: en,zh\n\n\nContent-Length\n响应体的长度\nContent-Length: 348\n\n\nContent-Location\n请求资源可替代的备用的另一地址\nContent-Location: &#x2F;index.htm\n\n\nContent-MD5\n返回资源的MD5校验值\nContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ&#x3D;&#x3D;\n\n\nContent-Range\n在整个返回体中本部分的字节位置\nContent-Range: bytes 21010-47021&#x2F;47022\n\n\nContent-Type\n如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码\nContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n\nDate\n原始服务器消息发出的时间\nDate: Tue, 15 Nov 2010 08:12:31 GMT\n\n\nETag\n请求变量的实体标签的当前值\nETag: “737060cd8c284d8af7ad3082f209582d”\n\n\nExpires\n响应过期的日期和时间\nExpires: Thu, 01 Dec 2010 16:00:00 GMT\n\n\nLast-Modified\n请求资源的最后修改时间\nLast-Modified: Tue, 15 Nov 2010 12:45:26 GMT\n\n\nLocation\n用来重定向接收方到非请求URL的位置来完成请求或标识新的资源\nLocation: http://www.zcmhi.com/archives/94.html\n\n\nPragma\n包括实现特定的指令，它可应用到响应链上的任何接收方\nPragma: no-cache\n\n\nProxy-Authenticate\n它指出认证方案和可应用到代理的该URL上的参数\nProxy-Authenticate: Basic\n\n\nrefresh\n应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）\nRefresh: 5; url&#x3D;http://www.zcmhi.com/archives/94.html\n\n\nRetry-After\n如果实体暂时不可取，通知客户端在指定时间之后再次尝试\nRetry-After: 120\n\n\nServer\nweb服务器软件名称\nServer: Apache&#x2F;1.3.27 (Unix) (Red-Hat&#x2F;Linux)\n\n\nSet-Cookie\n设置Http Cookie\nSet-Cookie: UserID&#x3D;JohnDoe; Max-Age&#x3D;3600; Version&#x3D;1\n\n\nTrailer\n指出头域在分块传输编码的尾部存在\nTrailer: Max-Forwards\n\n\nTransfer-Encoding\n文件传输编码\nTransfer-Encoding:chunked\n\n\nVary\n告诉下游代理是使用缓存响应还是从原始服务器请求\nVary: *\n\n\nVia\n告知代理客户端响应是通过哪里发送的\nVia: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1)\n\n\nWarning\n警告实体可能存在的问题\nWarning: 199 Miscellaneous warning\n\n\nWWW-Authenticate\n表明客户端请求实体应该使用的授权方案\nWWW-Authenticate: Basic\n\n\n","slug":"搞定 HTTP 协议","date":"2024-02-18T09:19:57.000Z","categories_index":"","tags_index":"网络协议","author_index":"哪吒"}]