{"title":"Compoer","uid":"709b09d4ae43a807a27c1aa5f06ca26b","slug":"Compoer","date":"2024-02-22T10:58:00.000Z","updated":"2024-02-22T11:13:14.223Z","comments":true,"path":"api/articles/Compoer.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>💡 Tips：先了解一下历史，从拷贝第三方代码到项目中(1994)，到 PEAR 安装依赖包(1999)，再到 Composer 兴起(2012)，PHP 社区经历了将近 20 年的探索。PHP 这门古老的语言，也在不断的发展更新，在 Web 领域一直发光发热。 Composer 作为目前 PHP 包依赖管理的最佳工具，值得每一位 PHP 开发人员掌握。</p></blockquote>\n<h3 id=\"什么是-Composer？\"><a href=\"#什么是-Composer？\" class=\"headerlink\" title=\"什么是 Composer？\"></a>什么是 Composer？</h3><p>是 PHP 用来管理依赖（dependency）关系的工具。可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会自动安装这些依赖的库文件。</p>\n<h3 id=\"Compoer-用法\"><a href=\"#Compoer-用法\" class=\"headerlink\" title=\"Compoer 用法\"></a>Compoer 用法</h3><p>项目中的 <strong>composer.json</strong> 文件是 Composer 的核心配置文件，它规定了项目所需的依赖包以及它们的版本信息，从而指导 Composer 安装和管理这些依赖项。该文件中最重要的部分是 require 部分，该部分告诉 Composer 期望安装的包及其版本：</p>\n<div align=center><img src=\"https://cdn.jsdelivr.net/gh/NezhaGrin/MyImages/20240222180946.png\"></div>\n\n<h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer install</span><br></pre></td></tr></table></figure>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>在项目根目录下执行，composer install 命令，Composer 会自动分析依赖，安装最合适的包到 vendor 目录下，安装完毕后，vendor 目录下会生成 autoload.php 文件。在项目的入口文件中包含此文件：require DIR . “&#x2F;vendor&#x2F;autoload.php”;，接下来便可在项目的任何地方引用依赖包中的接口和类。</p>\n</div>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>composer search</td>\n<td>根据关键字查找依赖包</td>\n</tr>\n<tr>\n<td>composer request</td>\n<td>引入依赖，声明项目或者全局( global，用户名全局，非系统全局)依赖某个包</td>\n</tr>\n<tr>\n<td>composer install</td>\n<td>安装 composer.json 声明的依赖包，最终安装的依赖包版本可能取决于有无 composer.lock 文件</td>\n</tr>\n<tr>\n<td>composer update</td>\n<td>更新依赖到最新版本，相当于删除 composer.lock 文件后执行 composer install</td>\n</tr>\n<tr>\n<td>composer info</td>\n<td>查看安装的依赖包信息，与 composer show 等价</td>\n</tr>\n<tr>\n<td>composer dumpautoload</td>\n<td>加 -o 选项可导出优化的加载器</td>\n</tr>\n<tr>\n<td>composer why(-not)</td>\n<td>查看（不）安装某个包的原因</td>\n</tr>\n</tbody></table>\n<h3 id=\"Composer-加速\"><a href=\"#Composer-加速\" class=\"headerlink\" title=\"Composer 加速\"></a>Composer 加速</h3><p>Compoer 安装依赖比较慢，问题是资源都是在外国服务器上，Compoer 2.x 除了网络问题，它已经很快了，不需要在使用其它插件辅助了。切换国内源，所有的项目都会使用该镜像地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Composer-加载机制\"><a href=\"#Composer-加载机制\" class=\"headerlink\" title=\"Composer 加载机制\"></a>Composer 加载机制</h3><p>Composer 是 PHP 中最受欢迎的依赖管理工具之一，它通过自动加载机制有效地管理项目的依赖关系。了解 Composer 的加载机制对于理解 PHP 项目的自动加载过程至关重要。</p>\n<h4 id=\"1-composer-json-文件\"><a href=\"#1-composer-json-文件\" class=\"headerlink\" title=\"1. composer.json 文件\"></a>1. composer.json 文件</h4><ul>\n<li><strong>依赖声明：</strong> composer.json 文件是 Composer 的核心配置文件，其中声明了项目所需的依赖包及其版本要求；</li>\n<li><strong>自动加载配置：</strong> composer.json 中的 <strong>autoload</strong> 字段定义了自动加载规则，告诉 Composer 如何加载项目中的类文件；</li>\n</ul>\n<h4 id=\"2-自动加载规则\"><a href=\"#2-自动加载规则\" class=\"headerlink\" title=\"2. 自动加载规则\"></a>2. 自动加载规则</h4><p>Composer 的自动加载规则基于 PSR-4 和 PSR-0 标准：</p>\n<ul>\n<li><strong>PSR-4 规范：</strong> PSR-4 规定了类命名空间与目录结构之间的映射关系；</li>\n<li><strong>PSR-0 规范：</strong> PSR-0 是早期的自动加载规范，已被 PSR-4 取代，但一些旧版的库仍然使用；</li>\n</ul>\n<h4 id=\"3-Composer-Autoload-指令\"><a href=\"#3-Composer-Autoload-指令\" class=\"headerlink\" title=\"3. Composer Autoload 指令\"></a>3. Composer Autoload 指令</h4><p>Composer Autoload 指令是项目中的 autoload.php 文件，由 Composer 自动生成并负责自动加载类文件：</p>\n<ul>\n<li><strong>引入 Autoload 文件：</strong> 项目的入口文件通常会引入 <strong>Composer 自动生成的 autoload.php 文件</strong>；</li>\n<li><strong>Autoload 机制：</strong> autoload.php 文件通过注册自动加载函数（<strong>spl_autoload_register</strong>）来实现类的自动加载；</li>\n</ul>\n<h4 id=\"4-类的加载流程\"><a href=\"#4-类的加载流程\" class=\"headerlink\" title=\"4. 类的加载流程\"></a>4. 类的加载流程</h4><ul>\n<li><strong>自动加载注册：</strong> 项目启动时，autoload.php 文件会注册自动加载函数，用于加载项目中的类文件；</li>\n<li><strong>命名空间解析：</strong> 当代码中使用了未加载的类时，PHP 解释器会触发自动加载函数；</li>\n<li><strong>自动加载函数：</strong> 自动加载函数根据类的命名空间和自动加载规则，找到对应的类文件并加载；</li>\n</ul>\n<h4 id=\"5-缓存机制\"><a href=\"#5-缓存机制\" class=\"headerlink\" title=\"5. 缓存机制\"></a>5. 缓存机制</h4><p>Composer 提供了类加载的缓存机制，可以加速加载过程：</p>\n<ul>\n<li><strong>Classmap：</strong> Composer 可以生成一个<strong>类映射表</strong>，加速类文件的查找过程；</li>\n<li><strong>Optimize-autoloader：</strong> Composer 提供了 optimize-autoloader 指令（<strong>composer dumpautoload -o</strong>），用于生成和更新类加载的缓存文件；</li>\n</ul>\n<h3 id=\"实现自动加载\"><a href=\"#实现自动加载\" class=\"headerlink\" title=\"实现自动加载\"></a>实现自动加载</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义项目根目录常量</span></span><br><span class=\"line\"><span class=\"title function_ invoke__\">define</span>(<span class=\"string\">&#x27;ROOT_PATH&#x27;</span>, <span class=\"keyword\">__DIR__</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自动加载函数</span></span><br><span class=\"line\"><span class=\"title function_ invoke__\">spl_autoload_register</span>(function (<span class=\"variable\">$className</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将类名转换为文件路径</span></span><br><span class=\"line\">    <span class=\"variable\">$classFile</span> = ROOT_PATH . <span class=\"string\">&#x27;/&#x27;</span> . <span class=\"title function_ invoke__\">str_replace</span>(<span class=\"string\">&#x27;\\\\&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"variable\">$className</span>) . <span class=\"string\">&#x27;.php&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 检查类文件是否存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_ invoke__\">file_exists</span>(<span class=\"variable\">$classFile</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 加载类文件</span></span><br><span class=\"line\">        <span class=\"keyword\">require_once</span> <span class=\"variable\">$classFile</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可选的其他初始化逻辑...</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p><code>spl_autoload_register</code> 函数用于<strong>注册自定义的自动加载函数</strong>，当 PHP 遇到未定义的类时，会触发这些自动加载函数来尝试加载对应的类文件。具体来说，<code>spl_autoload_register</code> 函数的调用会触发两种情况下的自动加载：</p>\n<ol>\n<li><strong>使用未定义的类：</strong> 当代码中使用了一个未定义的类时，PHP 解释器会检测当前是否已经注册了自动加载函数。如果已经注册，则会按照注册的顺序依次调用这些自动加载函数，尝试加载这个未定义的类；</li>\n<li><strong>手动调用 <code>spl_autoload</code> 函数：</strong> 如果需要手动触发自动加载，可以调用 <code>spl_autoload</code> 函数，并传入未定义的类名作为参数。这样 PHP 会立即尝试调用已注册的自动加载函数来加载这个类；</li>\n</ol>\n</p>\n</div>\n","feature":true,"text":"Composer 作为目前 PHP 包依赖管理的最佳工具，值得每一位 PHP 开发人员掌握。...","permalink":"/post/Compoer","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"PHP","slug":"PHP","count":1,"path":"api/tags/PHP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-Composer%EF%BC%9F\"><span class=\"toc-text\">什么是 Composer？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Compoer-%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">Compoer 用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">安装依赖</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">常用命令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Composer-%E5%8A%A0%E9%80%9F\"><span class=\"toc-text\">Composer 加速</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Composer-%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Composer 加载机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-composer-json-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">1. composer.json 文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99\"><span class=\"toc-text\">2. 自动加载规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Composer-Autoload-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">3. Composer Autoload 指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">4. 类的加载流程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">5. 缓存机制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">实现自动加载</span></a></li></ol>","author":{"name":"哪吒","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/65ba193b871b83018a65323c.jpg","link":"/","description":"人心中的成见就像一座大山，任你怎么努力也休想搬动。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Docker","uid":"a48e6dda0c21e40880cba7e763278b04","slug":"Docker","date":"2024-02-22T08:03:32.000Z","updated":"2024-02-22T11:36:02.885Z","comments":true,"path":"api/articles/Docker.json","keywords":null,"cover":null,"text":"Docker 是一个开源的容器化平台，用于轻松打包、发布和运行应用程序。通过 Docker，开发者可以将应用程序及其依赖项打包到一个称为镜像的标准化单元中，然后在任何支持 Docker 的环境中部署这些镜像为容器。...","permalink":"/post/Docker","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"author":{"name":"哪吒","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/65ba193b871b83018a65323c.jpg","link":"/","description":"人心中的成见就像一座大山，任你怎么努力也休想搬动。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}